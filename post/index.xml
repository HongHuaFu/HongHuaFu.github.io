<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on 月光下的旅行</title>
    <link>https://honghuafu.github.io/post/</link>
    <description>Recent content in Posts on 月光下的旅行</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <copyright>copyright.</copyright>
    <lastBuildDate>Fri, 06 Nov 2020 19:50:26 +0800</lastBuildDate><atom:link href="https://honghuafu.github.io/post/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>About</title>
      <link>https://honghuafu.github.io/post/about/</link>
      <pubDate>Fri, 06 Nov 2020 19:50:26 +0800</pubDate>
      
      <guid>https://honghuafu.github.io/post/about/</guid>
      <description>Hello</description>
    </item>
    
    <item>
      <title>虚幻4.22移动端实现GrabPass抓屏</title>
      <link>https://honghuafu.github.io/post/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/ue4.22%E7%A7%BB%E5%8A%A8%E7%AB%AF%E5%AE%9E%E7%8E%B0grabpass%E6%8A%93%E5%B1%8F/</link>
      <pubDate>Thu, 05 Nov 2020 23:41:02 +0800</pubDate>
      
      <guid>https://honghuafu.github.io/post/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/ue4.22%E7%A7%BB%E5%8A%A8%E7%AB%AF%E5%AE%9E%E7%8E%B0grabpass%E6%8A%93%E5%B1%8F/</guid>
      <description>最近几天在给UE4.22加上GrabPass这个功能，主要问题还是UE4移动端内部管线的折射太过操蛋（滔哥说的），折射材质在后处理阶段单独渲染一次扭曲VectorPass，然后再和SceneColor做合成。
UE这么做的原因还是因为移动端的GPU架构实在是不合适使用GrabPass的功能，移动端的GPU都是区块状的TBDR架构，虽然有 frame buffer fetch 扩展可以快速的拿到片上的buffer缓存，但是如果想要像要Copy Frame Buffer的话还是非常非常的耗的。
但UE4这种折射的做法带来了新的问题，折射的物体在后处理阶段渲染，那么所有的半透明材质，包括位于折射物体前面的特效，都会被这个折射物体扭曲，看着非常的难受。
UE4.22貌似有个分离不透明物体渲染pass的选项，但是勾上了就没办法使用Bloom效果，比较好的方式还是使用GrabPass类似的效果，像Unity那样。
我参考了Custom Depth的做法，在材质编辑器中的Scene Textures中注册了一个新的Global Texture，然后在Mobile的Render函数中插入了我的GrabPass函数，我想把GrabPass放在第一个要求抓屏贴图的网格渲染前调用，就像Unity那样，但是当我看了看Mobile的Translucency渲染调用，MeshDrawCommand List堆叠的整整齐齐的，然后来个Flush，完全没有我GrabPass插入的位置。
于是我只能在Opaque Mask渲染完后GrabPass了。
最后，在GrabPass时会遇到MSAA的一些小问题（实际上是大问题，我花了三天时间测试不同的机型来确定是否真的会发生），UDN上有大佬说GrabPass后MSAA的Depth Render Buffer会发生Resolve，然后再也Store不回来了。不过我在GrabPass时，显式禁用了该Pass的DepthStencil，在Renderdoc上查看Depth的Render Buffer并没有使用到，仅仅Resolve了SceneColor，后面的Pass也一切正常。
但正常的只有小米手机，华为手机则发生了错误，在同时使用了MSAA和GrabPass时，我的SceneColor Resolve后再也拿不回来了，淦。但是使用Memory Copy的方式可以有效解决这个问题，我看了UE的Copy函数，它先调用了glcopyimagesubdata复制一份原生的数据，再在cpu上解析复制出来的数据，也就是说，使用Copy是不会修改原来的Buffer数据的。
但这也让我很不爽，因为不论是Shader Draw Copy的方式，还是Memory Copy的方式，都在红米Note8上多消耗了3ms。我原先的打算是通过渲染1/2屏，1/4屏这样的方式做性能适配，现在似乎没这么轻松了。</description>
    </item>
    
    <item>
      <title>虚幻引擎4.22手机添加一次Z-PrePass</title>
      <link>https://honghuafu.github.io/post/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/ue4.22%E7%A7%BB%E5%8A%A8%E7%AB%AF%E6%B7%BB%E5%8A%A0%E4%B8%80%E6%AC%A1z-prepass/</link>
      <pubDate>Wed, 21 Oct 2020 22:50:02 +0800</pubDate>
      
      <guid>https://honghuafu.github.io/post/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/ue4.22%E7%A7%BB%E5%8A%A8%E7%AB%AF%E6%B7%BB%E5%8A%A0%E4%B8%80%E6%AC%A1z-prepass/</guid>
      <description>得益于UE4 MeshDrawCommand架构的优良设计，为引擎渲染管线添加一个Pass变得非常的简单。在看完虚幻官方给出的文档后，我开始修改Mobile的渲染管线，原本以为需要自己定义一套Mesh Collector流程，自己写一遍shader binding，却发现引擎的Defferd管线的PrePass非常适合做这个，这节省了我大量的时间，我只需要额外注册一个Mobile的 PrePass就可以在BuildMeshDrawCommand中收集PrePass需要的一切信息，在MobileShadingRender中在MobileBasePass之前插入一次，一切都搞定了，最后再针对美术的使用体验修改一下编辑器界面，就完事了，非常的简单粗暴。
实际上为Mobile添加一个PrePass一个下午就弄完了，接下来的一个星期时间都是在打包测试（不是划水，因为打包实在太慢了，一天基本只能测3-4个包这样子），放在RenderDoc中测了一下，DrawCall多了近50%，但时间却整体减少了 5 - 6 ms。在材质复杂程度更高时，优化会更加明显。
另外，PrePass的Early-Z优化在低端机上更加明显，低端机的View Distance比较近，小件物体没有渲染，额外的drawcall数并不多，提升能达到惊人的10-12ms(也许是我们之前的优化做得太渣了)。
开启了PrePass后，注意Z Func的切换，Base Pass使用 Z-Equal能节省近15%的时间，原因在于 Z-Equal开启时，Mask材质在片元着色器之前的深度测试中直接可以测试了，无须采样Mask贴图来确定哪一部分为镂空。
PrePass 在低端机的Z-Test可能会出现问题：在使用了world position offset选项的材质中出现闪烁现象。这是因为 物体使用了时间驱动的顶点动画，在渲染PrePass时输入的时间 != 渲染BasePass时输入的时间，Z-Test Equal 实际上并不等，于是出现闪烁，目前还没有比较好的解决办法，除非调整美术的动画时间精度，我暂时把它给屏蔽了。
最后，主动给角色、大地形的Material Blend Mode切换为Mask，可以让它们参与到 Mask Only PrePass的流程中，最大程度减少DrawCall同时减少Overdraw。
注：我发现UE4.25已经看到PrePass添加到移动管线上去了，不过它是 Mask Only的，并且目前这个特性并没有放出来。在未来的版本可能会有吧。</description>
    </item>
    
    <item>
      <title>虚幻4移动端级联阴影ShadowMap使用率过低问题修复</title>
      <link>https://honghuafu.github.io/post/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/ue4.22%E7%A7%BB%E5%8A%A8%E7%AB%AF%E7%BA%A7%E8%81%94%E9%98%B4%E5%BD%B1shadowmap%E4%BD%BF%E7%94%A8%E7%8E%87%E8%BF%87%E4%BD%8E%E9%97%AE%E9%A2%98%E4%BF%AE%E5%A4%8D/</link>
      <pubDate>Sat, 17 Oct 2020 22:25:32 +0800</pubDate>
      
      <guid>https://honghuafu.github.io/post/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/ue4.22%E7%A7%BB%E5%8A%A8%E7%AB%AF%E7%BA%A7%E8%81%94%E9%98%B4%E5%BD%B1shadowmap%E4%BD%BF%E7%94%A8%E7%8E%87%E8%BF%87%E4%BD%8E%E9%97%AE%E9%A2%98%E4%BF%AE%E5%A4%8D/</guid>
      <description>在微软家的这篇 [Common Techniques to Improve Shadow Depth Maps]文章中，详细讨论Shadow Map的各种问题和解决方案，里面的摩尔纹、Peter Pan、抗锯齿等常规问题都有着详细的解决方案。在简述Shadow Camera Setup的时候，他们简单提了下Shadow Camera Fit To Scene和Fit To View的两种做法，而这两种做法区别，对ShadowMap的利用率影响非常的大。
UE4内部的阴影解决方案很多，不过移动端能用上的就只有CSM。为了兼顾移动端的性能表现，设置CSM的数目 = 1就够用了，这时候的CSM实际上和单纯的Project ShadowMap算法没啥太大区别了，但是CSM数目设置为1时，UE4的阴影显得非常的淡，在人物角色上阴影表现得非常的轻浮，没有色彩感官上体现的厚重感，层次感也没体现出来，大场景时感觉还好。在人物特写的角色展示界面，这阴影质量根本不够用，emm，我记得我第一天搬下来游缘的时候滔哥就跟我说UE的阴影有问题，不过那时啥都不会天天划水（当然现在也啥都不会天天划水），过了好几个月都不想动这个阴影，直到最近几天有空了于是安排时间来解决这个问题。
国庆放假回来后就开始着手解决这些问题，修改这部分的源码，一共花了大概四天时间来看引擎的CSM部分的源码，我一开始的重心是放在了阴影相机的投影矩阵构建函数上，在那里折腾了好久吧，实际上也没啥收获，不过后来在微软家的DX12 Samples里发现了Mesh Viewer实例工程，里面的Sponza阴影贴图蛮好的。而微软他们家构建投影矩阵的方式和UE4也一样，唯一不同的就是相机视锥包围盒的构建方式不同，微软他们家是写死了的。UE4使用了Fit To View的方式。
UE4级联阴影Project Matrix的Setup步骤如下：
 根据编辑器中的CSM设置计算CSM每一级的范围距离等信息。GetShadowSplitBounds 计算当前级联的视锥体包围球。GetShadowSplitBoundsDepthRange 根据当前包围球范围剔除包围球外的投影体。 根据包围球设置阴影相机的投影矩阵。  在上面四个步骤中，有意思的地方是步骤二的包围球计算。他们先计算了视锥的八个顶点，然后根据这八个顶点计算一个包围球。算法如下：
// Calculate the ideal bounding sphere for the subfrustum. // Fx = (Db^2 - da^2) / 2Fl + Fl / 2 // (where Da is the far diagonal, and Db is the near, and Fl is the frustum length) float OptimalOffset = (DiagonalBSq - DiagonalASq) / (2.</description>
    </item>
    
    <item>
      <title>Substance Painter Shader与UE4移动端渲染效果同步</title>
      <link>https://honghuafu.github.io/post/%E5%AE%9E%E6%97%B6%E6%B8%B2%E6%9F%93%E6%95%88%E6%9E%9C/substance-painter%E4%B8%8Eue4%E9%85%8D%E5%A5%97shader/</link>
      <pubDate>Sat, 26 Sep 2020 22:43:32 +0800</pubDate>
      
      <guid>https://honghuafu.github.io/post/%E5%AE%9E%E6%97%B6%E6%B8%B2%E6%9F%93%E6%95%88%E6%9E%9C/substance-painter%E4%B8%8Eue4%E9%85%8D%E5%A5%97shader/</guid>
      <description>要为UE4项目编写SP的Shader，首先得把MobileBasePassXXX.usf翻出来。然后将通用的直射光 漫反射+ 高光 + Skylight + IBL全拿出来，再和特殊材质如SSS、Aniso等材质编辑器中的Shader拿出来，组合一下，就完成了。
参考了Substance Painter提供的示例Shader。很快就熟悉了SP的Shader编写方式。
这里给个超简洁的 SP Shader示例：https://github.com/ianbanks/arma_3_substance_shader
然后经过长时间的摸索和涛哥指导，SP Shader注意项：
 IBL计算必须和UE4 中的一样。绝对不能使用Substance Painter提供pbrComputeSpecular，差距非常的大，SP这个函数用了多次重要性采样积分，效果好得不得了。UE4 Mobile 的IBL就根据Roughness采样Cubemap lod，然后简单平方乘上一个亮度值，非常的搓。 环境贴图使用LDR，UE4 Mobile的光照图就是LDR，HDR会相对过曝了，美术他们绘制时可能会因为HDR关系把BaseColor亮度级别拉得相对较暗，导入引擎时有差距。 必须写在同一个Shader中。我一开始直接写了个模板，然后python根据输入参数不同生成不同的shader文件，比如皮肤一个，头发一个，丝绸一个。这导致模型进SP时得分开材质，导出时贴图没办法合并在一起。虽然可以在Substance Designer中合并贴图，但是SP导出时必须将填充像素减少到 1- 2。否则合并时UV岛会相交。然后这也会导致另外一个问题，合并完后UV岛边界填充少，贴图Mipmap会有texture bleeding现象，也就是远处有道缝。必须在python里再扩充一次UV岛，虽然问题最后解决了，但这美术工序越来越复杂了，最终只好全部写在一个Shader中，让美术额外绘制材质遮罩好了。 ToneMapper部分也要加上去，直接写在Shader中就好了，因为调色影响很大，UE4的ToneMapper是他改过的Film函数，我直接Copy过来一个字都没改，当然需要注意改一下DX和Opengl矩阵的行列主序问题和矩阵乘法部分。  最后记录我想出来的一个简单UV岛扩张的算法：
 计算当前贴图的黑白剪影。对黑白剪影做一次图像膨胀操作。得到扩展图。 然后对黑白剪影做一次边缘检测操作，记录所有边缘的rgb值。 将边缘的rgb值填充到剪影的膨胀区域上去。  简单快速，使用python opencv库一下子就搞定了。
最后：
SP与UE4一直有一个奇怪的色差问题，两者的颜色饱和度区间并不相同，我坚信是IBL的差异，然后使用了同一套IBL SPECULAR后，确实减少了很多差异，但色差还是有的，我无法解决这个问题。</description>
    </item>
    
    <item>
      <title>各向异性材质渲染与美术流程注意事项</title>
      <link>https://honghuafu.github.io/post/%E5%AE%9E%E6%97%B6%E6%B8%B2%E6%9F%93%E6%95%88%E6%9E%9C/%E4%B8%9D%E7%BB%B8%E5%A4%B4%E5%8F%91%E5%90%84%E5%90%91%E5%BC%82%E6%80%A7%E6%9D%90%E8%B4%A8%E6%B8%B2%E6%9F%93%E4%B8%8E%E7%BE%8E%E6%9C%AF%E5%88%B6%E4%BD%9C%E6%B5%81%E7%A8%8B%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/</link>
      <pubDate>Wed, 08 Jul 2020 21:23:32 +0800</pubDate>
      
      <guid>https://honghuafu.github.io/post/%E5%AE%9E%E6%97%B6%E6%B8%B2%E6%9F%93%E6%95%88%E6%9E%9C/%E4%B8%9D%E7%BB%B8%E5%A4%B4%E5%8F%91%E5%90%84%E5%90%91%E5%BC%82%E6%80%A7%E6%9D%90%E8%B4%A8%E6%B8%B2%E6%9F%93%E4%B8%8E%E7%BE%8E%E6%9C%AF%E5%88%B6%E4%BD%9C%E6%B5%81%E7%A8%8B%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/</guid>
      <description>原理 丝绸、头发这些各项异性材质，它们的高光部分计算使用的是各向异性方式。当然实时渲染里不可能像离线渲染里那样去积分计算，游戏中大部分都是用切线代替法线来近似计算各向异性高光。
然后高光的计算方式主要有三种，一个是Kaijya-Kay模型，它主要用在头发高光计算上。
Kaijya-Kay的高光计算方式：
它不再使用法线点积半角向量了，而是直接使用切线向量与半角向量的夹角的余弦值作为高光系数。
于是，当半角向量H与切线方向T夹角在[0,90°]时，按照正弦函数，夹角越小，得到的高光系数越小，然后幂乘后得到的高光值越小，然后当视线在发丝的落点沿着切线方向向发根平移时，H与T的夹角将会变大，高光值将会渐渐增大，从而形成头发顶部高光的感觉。
当然现在没有头发高光流动的感觉，为了模拟高光流动，它将切线沿着法线方向作偏移。
也就是这样：
half3 ShiftedTangent(float3 t, float3 n, float shift) { return normalize(t + shift * n); } 然后这个shift值一般采样一个偏移量灰度图：
这种灰度图可以在PS里用一个白噪声 + v方向的运动模糊生成。
当前shift值是[0,1]范围，将它作如下处理，使得高光可以随机向上向下流动:
float shift = tex2D(shitTex,uv).x - 0.5f; 最后是高光计算：
// T 为发丝切线方向，V为视线方向，L为灯光方向，exponent为高光幂指数 float StrandSpecular(float3 T, float3 V, float3 L, int exponent) { float3 H = normalize(L + V); float dotTH = dot(T, H); float sinTH = sqrt(1.0 - dotTH * dotTH); float dirAtten = smoothstep(-1, 0, dotTH); return dirAtten * pow(sinTH, exponent); } 这里的dirAtten主要是处理T与H夹角余弦落在[-1,0]之间，给一个高光值的衰减，处理视角向量与发丝切线接近重合时高光值异常问题。可以把它去掉来做一次比较，发现有方向衰减和没方向衰减的高光差异极大。</description>
    </item>
    
    <item>
      <title>简单翻页效果</title>
      <link>https://honghuafu.github.io/post/%E5%AE%9E%E6%97%B6%E6%B8%B2%E6%9F%93%E6%95%88%E6%9E%9C/%E7%AE%80%E6%98%93%E7%BF%BB%E9%A1%B5%E6%95%88%E6%9E%9C%E5%AE%9E%E7%8E%B0/</link>
      <pubDate>Fri, 03 Jul 2020 21:25:32 +0800</pubDate>
      
      <guid>https://honghuafu.github.io/post/%E5%AE%9E%E6%97%B6%E6%B8%B2%E6%9F%93%E6%95%88%E6%9E%9C/%E7%AE%80%E6%98%93%E7%BF%BB%E9%A1%B5%E6%95%88%E6%9E%9C%E5%AE%9E%E7%8E%B0/</guid>
      <description>翻页效果主要分为顶点着色器动画和UI遮罩动画。我简单的在Unity上分别实现这两个，然后移植到UE4上面去。
顶点着色器动画 顶点着色器实现实际上就是网格顶点变形动画，片元着色器就是简单的采样纹理着色，注意正面与背面的区别，重点在于顶点着色器，它的工作内容可以分为两大部分：
 顶点翻页变形，选择合适的圆锥曲线或者正弦曲线函数做顶点变化。 将顶点绕轴旋转合适的角度。  我首先实现步骤2，然后再实现步骤1。
首先是将顶点绕轴旋转合适的角度，输入是当前页面的旋转角度，然后将所有的顶点绕着装订轴旋转该角度。
输入模型是一个平面模型，10 * 10的平面网格，默认中心点在原点，因此需要将所有顶点都平移一段距离，使得旋转中心轴线在网格的左边或者右边。
// 旋转前将所有顶点移动到装订线处 v.vertex.x -= _PinLine; // 在这里旋转所有顶点 // 旋转后再移动回原位置 v.vertex.x += _PinLine; 然后旋转部分是绕z轴旋转，旋转矩阵为：
转换为代码是：
// 绕z轴旋转 float angle_rad = radians(-_Angle); float s;float c;sincos(angle_rad,s,c); float2 rotate_ret = v.vertex.xy; v.vertex.x = rotate_ret.x * c + rotate_ret.y * s; v.vertex.y = rotate_ret.y * c - rotate_ret.x * s; 我这里把矩阵展开了，实际上是一样的效果。
现在实现平面网格沿着z轴旋转的效果了。
接下来加上顶点的变形。
根据你选择数学函数的不同，顶点变形的效果也会呈现不同的形状，简单的有正弦曲面函数，复杂的有圆锥曲面函数，也可以用多个频率的正弦曲面函数叠加得到一个好看的形状，我这里试了正弦函数和圆锥曲面函数：
首先是正弦函数：
// 在这里执行顶点变形动画 float factor = saturate(1 - abs(90 - _Angle) / 90); v.</description>
    </item>
    
  </channel>
</rss>
