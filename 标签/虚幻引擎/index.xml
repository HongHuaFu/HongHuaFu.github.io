<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>虚幻引擎 on 月光下的旅行</title>
    <link>https://honghuafu.github.io/%E6%A0%87%E7%AD%BE/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/</link>
    <description>Recent content in 虚幻引擎 on 月光下的旅行</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <copyright>copyright.</copyright>
    <lastBuildDate>Thu, 05 Nov 2020 23:41:02 +0800</lastBuildDate><atom:link href="https://honghuafu.github.io/%E6%A0%87%E7%AD%BE/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>虚幻4.22移动端实现GrabPass抓屏</title>
      <link>https://honghuafu.github.io/post/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/ue4.22%E7%A7%BB%E5%8A%A8%E7%AB%AF%E5%AE%9E%E7%8E%B0grabpass%E6%8A%93%E5%B1%8F/</link>
      <pubDate>Thu, 05 Nov 2020 23:41:02 +0800</pubDate>
      
      <guid>https://honghuafu.github.io/post/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/ue4.22%E7%A7%BB%E5%8A%A8%E7%AB%AF%E5%AE%9E%E7%8E%B0grabpass%E6%8A%93%E5%B1%8F/</guid>
      <description>最近几天在给UE4.22加上GrabPass这个功能，主要问题还是UE4移动端内部管线的折射太过操蛋（滔哥说的），折射材质在后处理阶段单独渲染一次扭曲VectorPass，然后再和SceneColor做合成。
UE这么做的原因还是因为移动端的GPU架构实在是不合适使用GrabPass的功能，移动端的GPU都是区块状的TBDR架构，虽然有 frame buffer fetch 扩展可以快速的拿到片上的buffer缓存，但是如果想要像要Copy Frame Buffer的话还是非常非常的耗的。
但UE4这种折射的做法带来了新的问题，折射的物体在后处理阶段渲染，那么所有的半透明材质，包括位于折射物体前面的特效，都会被这个折射物体扭曲，看着非常的难受。
UE4.22貌似有个分离不透明物体渲染pass的选项，但是勾上了就没办法使用Bloom效果，比较好的方式还是使用GrabPass类似的效果，像Unity那样。
我参考了Custom Depth的做法，在材质编辑器中的Scene Textures中注册了一个新的Global Texture，然后在Mobile的Render函数中插入了我的GrabPass函数，我想把GrabPass放在第一个要求抓屏贴图的网格渲染前调用，就像Unity那样，但是当我看了看Mobile的Translucency渲染调用，MeshDrawCommand List堆叠的整整齐齐的，然后来个Flush，完全没有我GrabPass插入的位置。
于是我只能在Opaque Mask渲染完后GrabPass了。
最后，在GrabPass时会遇到MSAA的一些小问题（实际上是大问题，我花了三天时间测试不同的机型来确定是否真的会发生），UDN上有大佬说GrabPass后MSAA的Depth Render Buffer会发生Resolve，然后再也Store不回来了。不过我在GrabPass时，显式禁用了该Pass的DepthStencil，在Renderdoc上查看Depth的Render Buffer并没有使用到，仅仅Resolve了SceneColor，后面的Pass也一切正常。
但正常的只有小米手机，华为手机则发生了错误，在同时使用了MSAA和GrabPass时，我的SceneColor Resolve后再也拿不回来了，淦。但是使用Memory Copy的方式可以有效解决这个问题，我看了UE的Copy函数，它先调用了glcopyimagesubdata复制一份原生的数据，再在cpu上解析复制出来的数据，也就是说，使用Copy是不会修改原来的Buffer数据的。
但这也让我很不爽，因为不论是Shader Draw Copy的方式，还是Memory Copy的方式，都在红米Note8上多消耗了3ms。我原先的打算是通过渲染1/2屏，1/4屏这样的方式做性能适配，现在似乎没这么轻松了。</description>
    </item>
    
    <item>
      <title>虚幻引擎4.22手机添加一次Z-PrePass</title>
      <link>https://honghuafu.github.io/post/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/ue4.22%E7%A7%BB%E5%8A%A8%E7%AB%AF%E6%B7%BB%E5%8A%A0%E4%B8%80%E6%AC%A1z-prepass/</link>
      <pubDate>Wed, 21 Oct 2020 22:50:02 +0800</pubDate>
      
      <guid>https://honghuafu.github.io/post/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/ue4.22%E7%A7%BB%E5%8A%A8%E7%AB%AF%E6%B7%BB%E5%8A%A0%E4%B8%80%E6%AC%A1z-prepass/</guid>
      <description>得益于UE4 MeshDrawCommand架构的优良设计，为引擎渲染管线添加一个Pass变得非常的简单。在看完虚幻官方给出的文档后，我开始修改Mobile的渲染管线，原本以为需要自己定义一套Mesh Collector流程，自己写一遍shader binding，却发现引擎的Defferd管线的PrePass非常适合做这个，这节省了我大量的时间，我只需要额外注册一个Mobile的 PrePass就可以在BuildMeshDrawCommand中收集PrePass需要的一切信息，在MobileShadingRender中在MobileBasePass之前插入一次，一切都搞定了，最后再针对美术的使用体验修改一下编辑器界面，就完事了，非常的简单粗暴。
实际上为Mobile添加一个PrePass一个下午就弄完了，接下来的一个星期时间都是在打包测试（不是划水，因为打包实在太慢了，一天基本只能测3-4个包这样子），放在RenderDoc中测了一下，DrawCall多了近50%，但时间却整体减少了 5 - 6 ms。在材质复杂程度更高时，优化会更加明显。
另外，PrePass的Early-Z优化在低端机上更加明显，低端机的View Distance比较近，小件物体没有渲染，额外的drawcall数并不多，提升能达到惊人的10-12ms(也许是我们之前的优化做得太渣了)。
开启了PrePass后，注意Z Func的切换，Base Pass使用 Z-Equal能节省近15%的时间，原因在于 Z-Equal开启时，Mask材质在片元着色器之前的深度测试中直接可以测试了，无须采样Mask贴图来确定哪一部分为镂空。
PrePass 在低端机的Z-Test可能会出现问题：在使用了world position offset选项的材质中出现闪烁现象。这是因为 物体使用了时间驱动的顶点动画，在渲染PrePass时输入的时间 != 渲染BasePass时输入的时间，Z-Test Equal 实际上并不等，于是出现闪烁，目前还没有比较好的解决办法，除非调整美术的动画时间精度，我暂时把它给屏蔽了。
最后，主动给角色、大地形的Material Blend Mode切换为Mask，可以让它们参与到 Mask Only PrePass的流程中，最大程度减少DrawCall同时减少Overdraw。
注：我发现UE4.25已经看到PrePass添加到移动管线上去了，不过它是 Mask Only的，并且目前这个特性并没有放出来。在未来的版本可能会有吧。</description>
    </item>
    
    <item>
      <title>虚幻4移动端级联阴影ShadowMap使用率过低问题修复</title>
      <link>https://honghuafu.github.io/post/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/ue4.22%E7%A7%BB%E5%8A%A8%E7%AB%AF%E7%BA%A7%E8%81%94%E9%98%B4%E5%BD%B1shadowmap%E4%BD%BF%E7%94%A8%E7%8E%87%E8%BF%87%E4%BD%8E%E9%97%AE%E9%A2%98%E4%BF%AE%E5%A4%8D/</link>
      <pubDate>Sat, 17 Oct 2020 22:25:32 +0800</pubDate>
      
      <guid>https://honghuafu.github.io/post/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/ue4.22%E7%A7%BB%E5%8A%A8%E7%AB%AF%E7%BA%A7%E8%81%94%E9%98%B4%E5%BD%B1shadowmap%E4%BD%BF%E7%94%A8%E7%8E%87%E8%BF%87%E4%BD%8E%E9%97%AE%E9%A2%98%E4%BF%AE%E5%A4%8D/</guid>
      <description>在微软家的这篇 [Common Techniques to Improve Shadow Depth Maps]文章中，详细讨论Shadow Map的各种问题和解决方案，里面的摩尔纹、Peter Pan、抗锯齿等常规问题都有着详细的解决方案。在简述Shadow Camera Setup的时候，他们简单提了下Shadow Camera Fit To Scene和Fit To View的两种做法，而这两种做法区别，对ShadowMap的利用率影响非常的大。
UE4内部的阴影解决方案很多，不过移动端能用上的就只有CSM。为了兼顾移动端的性能表现，设置CSM的数目 = 1就够用了，这时候的CSM实际上和单纯的Project ShadowMap算法没啥太大区别了，但是CSM数目设置为1时，UE4的阴影显得非常的淡，在人物角色上阴影表现得非常的轻浮，没有色彩感官上体现的厚重感，层次感也没体现出来，大场景时感觉还好。在人物特写的角色展示界面，这阴影质量根本不够用，emm，我记得我第一天搬下来游缘的时候滔哥就跟我说UE的阴影有问题，不过那时啥都不会天天划水（当然现在也啥都不会天天划水），过了好几个月都不想动这个阴影，直到最近几天有空了于是安排时间来解决这个问题。
国庆放假回来后就开始着手解决这些问题，修改这部分的源码，一共花了大概四天时间来看引擎的CSM部分的源码，我一开始的重心是放在了阴影相机的投影矩阵构建函数上，在那里折腾了好久吧，实际上也没啥收获，不过后来在微软家的DX12 Samples里发现了Mesh Viewer实例工程，里面的Sponza阴影贴图蛮好的。而微软他们家构建投影矩阵的方式和UE4也一样，唯一不同的就是相机视锥包围盒的构建方式不同，微软他们家是写死了的。UE4使用了Fit To View的方式。
UE4级联阴影Project Matrix的Setup步骤如下：
 根据编辑器中的CSM设置计算CSM每一级的范围距离等信息。GetShadowSplitBounds 计算当前级联的视锥体包围球。GetShadowSplitBoundsDepthRange 根据当前包围球范围剔除包围球外的投影体。 根据包围球设置阴影相机的投影矩阵。  在上面四个步骤中，有意思的地方是步骤二的包围球计算。他们先计算了视锥的八个顶点，然后根据这八个顶点计算一个包围球。算法如下：
// Calculate the ideal bounding sphere for the subfrustum. // Fx = (Db^2 - da^2) / 2Fl + Fl / 2 // (where Da is the far diagonal, and Db is the near, and Fl is the frustum length) float OptimalOffset = (DiagonalBSq - DiagonalASq) / (2.</description>
    </item>
    
  </channel>
</rss>
