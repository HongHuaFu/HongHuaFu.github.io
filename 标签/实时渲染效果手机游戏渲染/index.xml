<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>实时渲染效果，手机游戏渲染 on 月光下的旅行</title>
    <link>https://honghuafu.github.io/%E6%A0%87%E7%AD%BE/%E5%AE%9E%E6%97%B6%E6%B8%B2%E6%9F%93%E6%95%88%E6%9E%9C%E6%89%8B%E6%9C%BA%E6%B8%B8%E6%88%8F%E6%B8%B2%E6%9F%93/</link>
    <description>Recent content in 实时渲染效果，手机游戏渲染 on 月光下的旅行</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <copyright>copyright.</copyright>
    <lastBuildDate>Sat, 26 Sep 2020 22:43:32 +0800</lastBuildDate><atom:link href="https://honghuafu.github.io/%E6%A0%87%E7%AD%BE/%E5%AE%9E%E6%97%B6%E6%B8%B2%E6%9F%93%E6%95%88%E6%9E%9C%E6%89%8B%E6%9C%BA%E6%B8%B8%E6%88%8F%E6%B8%B2%E6%9F%93/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Substance Painter Shader与UE4移动端渲染效果同步</title>
      <link>https://honghuafu.github.io/post/%E5%AE%9E%E6%97%B6%E6%B8%B2%E6%9F%93%E6%95%88%E6%9E%9C/substance-painter%E4%B8%8Eue4%E9%85%8D%E5%A5%97shader/</link>
      <pubDate>Sat, 26 Sep 2020 22:43:32 +0800</pubDate>
      
      <guid>https://honghuafu.github.io/post/%E5%AE%9E%E6%97%B6%E6%B8%B2%E6%9F%93%E6%95%88%E6%9E%9C/substance-painter%E4%B8%8Eue4%E9%85%8D%E5%A5%97shader/</guid>
      <description>要为UE4项目编写SP的Shader，首先得把MobileBasePassXXX.usf翻出来。然后将通用的直射光 漫反射+ 高光 + Skylight + IBL全拿出来，再和特殊材质如SSS、Aniso等材质编辑器中的Shader拿出来，组合一下，就完成了。
参考了Substance Painter提供的示例Shader。很快就熟悉了SP的Shader编写方式。
这里给个超简洁的 SP Shader示例：https://github.com/ianbanks/arma_3_substance_shader
然后经过长时间的摸索和涛哥指导，SP Shader注意项：
 IBL计算必须和UE4 中的一样。绝对不能使用Substance Painter提供pbrComputeSpecular，差距非常的大，SP这个函数用了多次重要性采样积分，效果好得不得了。UE4 Mobile 的IBL就根据Roughness采样Cubemap lod，然后简单平方乘上一个亮度值，非常的搓。 环境贴图使用LDR，UE4 Mobile的光照图就是LDR，HDR会相对过曝了，美术他们绘制时可能会因为HDR关系把BaseColor亮度级别拉得相对较暗，导入引擎时有差距。 必须写在同一个Shader中。我一开始直接写了个模板，然后python根据输入参数不同生成不同的shader文件，比如皮肤一个，头发一个，丝绸一个。这导致模型进SP时得分开材质，导出时贴图没办法合并在一起。虽然可以在Substance Designer中合并贴图，但是SP导出时必须将填充像素减少到 1- 2。否则合并时UV岛会相交。然后这也会导致另外一个问题，合并完后UV岛边界填充少，贴图Mipmap会有texture bleeding现象，也就是远处有道缝。必须在python里再扩充一次UV岛，虽然问题最后解决了，但这美术工序越来越复杂了，最终只好全部写在一个Shader中，让美术额外绘制材质遮罩好了。 ToneMapper部分也要加上去，直接写在Shader中就好了，因为调色影响很大，UE4的ToneMapper是他改过的Film函数，我直接Copy过来一个字都没改，当然需要注意改一下DX和Opengl矩阵的行列主序问题和矩阵乘法部分。  最后记录我想出来的一个简单UV岛扩张的算法：
 计算当前贴图的黑白剪影。对黑白剪影做一次图像膨胀操作。得到扩展图。 然后对黑白剪影做一次边缘检测操作，记录所有边缘的rgb值。 将边缘的rgb值填充到剪影的膨胀区域上去。  简单快速，使用python opencv库一下子就搞定了。
最后：
SP与UE4一直有一个奇怪的色差问题，两者的颜色饱和度区间并不相同，我坚信是IBL的差异，然后使用了同一套IBL SPECULAR后，确实减少了很多差异，但色差还是有的，我无法解决这个问题。</description>
    </item>
    
    <item>
      <title>各向异性材质渲染与美术流程注意事项</title>
      <link>https://honghuafu.github.io/post/%E5%AE%9E%E6%97%B6%E6%B8%B2%E6%9F%93%E6%95%88%E6%9E%9C/%E4%B8%9D%E7%BB%B8%E5%A4%B4%E5%8F%91%E5%90%84%E5%90%91%E5%BC%82%E6%80%A7%E6%9D%90%E8%B4%A8%E6%B8%B2%E6%9F%93%E4%B8%8E%E7%BE%8E%E6%9C%AF%E5%88%B6%E4%BD%9C%E6%B5%81%E7%A8%8B%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/</link>
      <pubDate>Wed, 08 Jul 2020 21:23:32 +0800</pubDate>
      
      <guid>https://honghuafu.github.io/post/%E5%AE%9E%E6%97%B6%E6%B8%B2%E6%9F%93%E6%95%88%E6%9E%9C/%E4%B8%9D%E7%BB%B8%E5%A4%B4%E5%8F%91%E5%90%84%E5%90%91%E5%BC%82%E6%80%A7%E6%9D%90%E8%B4%A8%E6%B8%B2%E6%9F%93%E4%B8%8E%E7%BE%8E%E6%9C%AF%E5%88%B6%E4%BD%9C%E6%B5%81%E7%A8%8B%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/</guid>
      <description>原理 丝绸、头发这些各项异性材质，它们的高光部分计算使用的是各向异性方式。当然实时渲染里不可能像离线渲染里那样去积分计算，游戏中大部分都是用切线代替法线来近似计算各向异性高光。
然后高光的计算方式主要有三种，一个是Kaijya-Kay模型，它主要用在头发高光计算上。
Kaijya-Kay的高光计算方式：
它不再使用法线点积半角向量了，而是直接使用切线向量与半角向量的夹角的余弦值作为高光系数。
于是，当半角向量H与切线方向T夹角在[0,90°]时，按照正弦函数，夹角越小，得到的高光系数越小，然后幂乘后得到的高光值越小，然后当视线在发丝的落点沿着切线方向向发根平移时，H与T的夹角将会变大，高光值将会渐渐增大，从而形成头发顶部高光的感觉。
当然现在没有头发高光流动的感觉，为了模拟高光流动，它将切线沿着法线方向作偏移。
也就是这样：
half3 ShiftedTangent(float3 t, float3 n, float shift) { return normalize(t + shift * n); } 然后这个shift值一般采样一个偏移量灰度图：
这种灰度图可以在PS里用一个白噪声 + v方向的运动模糊生成。
当前shift值是[0,1]范围，将它作如下处理，使得高光可以随机向上向下流动:
float shift = tex2D(shitTex,uv).x - 0.5f; 最后是高光计算：
// T 为发丝切线方向，V为视线方向，L为灯光方向，exponent为高光幂指数 float StrandSpecular(float3 T, float3 V, float3 L, int exponent) { float3 H = normalize(L + V); float dotTH = dot(T, H); float sinTH = sqrt(1.0 - dotTH * dotTH); float dirAtten = smoothstep(-1, 0, dotTH); return dirAtten * pow(sinTH, exponent); } 这里的dirAtten主要是处理T与H夹角余弦落在[-1,0]之间，给一个高光值的衰减，处理视角向量与发丝切线接近重合时高光值异常问题。可以把它去掉来做一次比较，发现有方向衰减和没方向衰减的高光差异极大。</description>
    </item>
    
    <item>
      <title>简单翻页效果</title>
      <link>https://honghuafu.github.io/post/%E5%AE%9E%E6%97%B6%E6%B8%B2%E6%9F%93%E6%95%88%E6%9E%9C/%E7%AE%80%E6%98%93%E7%BF%BB%E9%A1%B5%E6%95%88%E6%9E%9C%E5%AE%9E%E7%8E%B0/</link>
      <pubDate>Fri, 03 Jul 2020 21:25:32 +0800</pubDate>
      
      <guid>https://honghuafu.github.io/post/%E5%AE%9E%E6%97%B6%E6%B8%B2%E6%9F%93%E6%95%88%E6%9E%9C/%E7%AE%80%E6%98%93%E7%BF%BB%E9%A1%B5%E6%95%88%E6%9E%9C%E5%AE%9E%E7%8E%B0/</guid>
      <description>翻页效果主要分为顶点着色器动画和UI遮罩动画。我简单的在Unity上分别实现这两个，然后移植到UE4上面去。
顶点着色器动画 顶点着色器实现实际上就是网格顶点变形动画，片元着色器就是简单的采样纹理着色，注意正面与背面的区别，重点在于顶点着色器，它的工作内容可以分为两大部分：
 顶点翻页变形，选择合适的圆锥曲线或者正弦曲线函数做顶点变化。 将顶点绕轴旋转合适的角度。  我首先实现步骤2，然后再实现步骤1。
首先是将顶点绕轴旋转合适的角度，输入是当前页面的旋转角度，然后将所有的顶点绕着装订轴旋转该角度。
输入模型是一个平面模型，10 * 10的平面网格，默认中心点在原点，因此需要将所有顶点都平移一段距离，使得旋转中心轴线在网格的左边或者右边。
// 旋转前将所有顶点移动到装订线处 v.vertex.x -= _PinLine; // 在这里旋转所有顶点 // 旋转后再移动回原位置 v.vertex.x += _PinLine; 然后旋转部分是绕z轴旋转，旋转矩阵为：
转换为代码是：
// 绕z轴旋转 float angle_rad = radians(-_Angle); float s;float c;sincos(angle_rad,s,c); float2 rotate_ret = v.vertex.xy; v.vertex.x = rotate_ret.x * c + rotate_ret.y * s; v.vertex.y = rotate_ret.y * c - rotate_ret.x * s; 我这里把矩阵展开了，实际上是一样的效果。
现在实现平面网格沿着z轴旋转的效果了。
接下来加上顶点的变形。
根据你选择数学函数的不同，顶点变形的效果也会呈现不同的形状，简单的有正弦曲面函数，复杂的有圆锥曲面函数，也可以用多个频率的正弦曲面函数叠加得到一个好看的形状，我这里试了正弦函数和圆锥曲面函数：
首先是正弦函数：
// 在这里执行顶点变形动画 float factor = saturate(1 - abs(90 - _Angle) / 90); v.</description>
    </item>
    
  </channel>
</rss>
