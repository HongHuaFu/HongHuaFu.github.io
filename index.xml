<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>月光下的旅行</title>
    <link>http://localhost:1313/</link>
    <description>Recent content on 月光下的旅行</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <copyright>copyright.</copyright>
    <lastBuildDate>Fri, 06 Nov 2020 19:50:26 +0800</lastBuildDate>
    
        <atom:link href="http://localhost:1313/index.xml" rel="self" type="application/rss+xml" />
    
    
    
        <item>
        <title>About</title>
        <link>http://localhost:1313/post/about/</link>
        <pubDate>Fri, 06 Nov 2020 19:50:26 +0800</pubDate>
        
        <guid>http://localhost:1313/post/about/</guid>
        <description>月光下的旅行 http://localhost:1313/post/about/ -&lt;p&gt;Hello&lt;/p&gt;
- http://localhost:1313/post/about/ - copyright.</description>
        </item>
    
    
    
        <item>
        <title>虚幻4.22移动端实现GrabPass抓屏</title>
        <link>http://localhost:1313/post/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/ue4.22%E7%A7%BB%E5%8A%A8%E7%AB%AF%E5%AE%9E%E7%8E%B0grabpass%E6%8A%93%E5%B1%8F/</link>
        <pubDate>Thu, 05 Nov 2020 23:41:02 +0800</pubDate>
        
        <guid>http://localhost:1313/post/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/ue4.22%E7%A7%BB%E5%8A%A8%E7%AB%AF%E5%AE%9E%E7%8E%B0grabpass%E6%8A%93%E5%B1%8F/</guid>
        <description>月光下的旅行 http://localhost:1313/post/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/ue4.22%E7%A7%BB%E5%8A%A8%E7%AB%AF%E5%AE%9E%E7%8E%B0grabpass%E6%8A%93%E5%B1%8F/ -&lt;p&gt;最近几天在给UE4.22加上GrabPass这个功能，主要问题还是UE4移动端内部管线的折射太过操蛋（滔哥说的），折射材质在后处理阶段单独渲染一次扭曲VectorPass，然后再和SceneColor做合成。&lt;/p&gt;
&lt;p&gt;UE这么做的原因还是因为移动端的GPU架构实在是不合适使用GrabPass的功能，移动端的GPU都是区块状的TBDR架构，虽然有 frame buffer fetch 扩展可以快速的拿到片上的buffer缓存，但是如果想要像要Copy Frame Buffer的话还是非常非常的耗的。&lt;/p&gt;
&lt;p&gt;但UE4这种折射的做法带来了新的问题，折射的物体在后处理阶段渲染，那么所有的半透明材质，包括位于折射物体前面的特效，都会被这个折射物体扭曲，看着非常的难受。&lt;/p&gt;
&lt;p&gt;UE4.22貌似有个分离不透明物体渲染pass的选项，但是勾上了就没办法使用Bloom效果，比较好的方式还是使用GrabPass类似的效果，像Unity那样。&lt;/p&gt;
&lt;p&gt;我参考了Custom Depth的做法，在材质编辑器中的Scene Textures中注册了一个新的Global Texture，然后在Mobile的Render函数中插入了我的GrabPass函数，我想把GrabPass放在第一个要求抓屏贴图的网格渲染前调用，就像Unity那样，但是当我看了看Mobile的Translucency渲染调用，MeshDrawCommand List堆叠的整整齐齐的，然后来个Flush，完全没有我GrabPass插入的位置。&lt;/p&gt;
&lt;p&gt;于是我只能在Opaque Mask渲染完后GrabPass了。&lt;/p&gt;
&lt;p&gt;最后，在GrabPass时会遇到MSAA的一些小问题（实际上是大问题，我花了三天时间测试不同的机型来确定是否真的会发生），UDN上有大佬说GrabPass后MSAA的Depth Render Buffer会发生Resolve，然后再也Store不回来了。不过我在GrabPass时，显式禁用了该Pass的DepthStencil，在Renderdoc上查看Depth的Render Buffer并没有使用到，仅仅Resolve了SceneColor，后面的Pass也一切正常。&lt;/p&gt;
&lt;p&gt;但正常的只有小米手机，华为手机则发生了错误，在同时使用了MSAA和GrabPass时，我的SceneColor Resolve后再也拿不回来了，淦。但是使用Memory Copy的方式可以有效解决这个问题，我看了UE的Copy函数，它先调用了glcopyimagesubdata复制一份原生的数据，再在cpu上解析复制出来的数据，也就是说，使用Copy是不会修改原来的Buffer数据的。&lt;/p&gt;
&lt;p&gt;但这也让我很不爽，因为不论是Shader Draw Copy的方式，还是Memory Copy的方式，都在红米Note8上多消耗了3ms。我原先的打算是通过渲染1/2屏，1/4屏这样的方式做性能适配，现在似乎没这么轻松了。&lt;/p&gt;
- http://localhost:1313/post/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/ue4.22%E7%A7%BB%E5%8A%A8%E7%AB%AF%E5%AE%9E%E7%8E%B0grabpass%E6%8A%93%E5%B1%8F/ - copyright.</description>
        </item>
    
    
    
        <item>
        <title>虚幻引擎4.22手机添加一次Z-PrePass</title>
        <link>http://localhost:1313/post/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/ue4.22%E7%A7%BB%E5%8A%A8%E7%AB%AF%E6%B7%BB%E5%8A%A0%E4%B8%80%E6%AC%A1z-prepass/</link>
        <pubDate>Wed, 21 Oct 2020 22:50:02 +0800</pubDate>
        
        <guid>http://localhost:1313/post/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/ue4.22%E7%A7%BB%E5%8A%A8%E7%AB%AF%E6%B7%BB%E5%8A%A0%E4%B8%80%E6%AC%A1z-prepass/</guid>
        <description>月光下的旅行 http://localhost:1313/post/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/ue4.22%E7%A7%BB%E5%8A%A8%E7%AB%AF%E6%B7%BB%E5%8A%A0%E4%B8%80%E6%AC%A1z-prepass/ -&lt;p&gt;得益于UE4 MeshDrawCommand架构的优良设计，为引擎渲染管线添加一个Pass变得非常的简单。在看完虚幻官方给出的文档后，我开始修改Mobile的渲染管线，原本以为需要自己定义一套Mesh Collector流程，自己写一遍shader binding，却发现引擎的Defferd管线的PrePass非常适合做这个，这节省了我大量的时间，我只需要额外注册一个Mobile的 PrePass就可以在BuildMeshDrawCommand中收集PrePass需要的一切信息，在MobileShadingRender中在MobileBasePass之前插入一次，一切都搞定了，最后再针对美术的使用体验修改一下编辑器界面，就完事了，非常的简单粗暴。&lt;/p&gt;
&lt;p&gt;实际上为Mobile添加一个PrePass一个下午就弄完了，接下来的一个星期时间都是在打包测试（不是划水，因为打包实在太慢了，一天基本只能测3-4个包这样子），放在RenderDoc中测了一下，DrawCall多了近50%，但时间却整体减少了 5 - 6 ms。在材质复杂程度更高时，优化会更加明显。&lt;/p&gt;
&lt;p&gt;另外，PrePass的Early-Z优化在低端机上更加明显，低端机的View Distance比较近，小件物体没有渲染，额外的drawcall数并不多，提升能达到惊人的10-12ms(也许是我们之前的优化做得太渣了)。&lt;/p&gt;
&lt;p&gt;开启了PrePass后，注意Z Func的切换，Base Pass使用 Z-Equal能节省近15%的时间，原因在于 Z-Equal开启时，Mask材质在片元着色器之前的深度测试中直接可以测试了，无须采样Mask贴图来确定哪一部分为镂空。&lt;/p&gt;
&lt;p&gt;PrePass 在低端机的Z-Test可能会出现问题：在使用了world position offset选项的材质中出现闪烁现象。这是因为 物体使用了时间驱动的顶点动画，在渲染PrePass时输入的时间 != 渲染BasePass时输入的时间，Z-Test Equal 实际上并不等，于是出现闪烁，目前还没有比较好的解决办法，除非调整美术的动画时间精度，我暂时把它给屏蔽了。&lt;/p&gt;
&lt;p&gt;最后，主动给角色、大地形的Material Blend Mode切换为Mask，可以让它们参与到 Mask Only PrePass的流程中，最大程度减少DrawCall同时减少Overdraw。&lt;/p&gt;
&lt;p&gt;注：我发现UE4.25已经看到PrePass添加到移动管线上去了，不过它是 Mask Only的，并且目前这个特性并没有放出来。在未来的版本可能会有吧。&lt;/p&gt;
- http://localhost:1313/post/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/ue4.22%E7%A7%BB%E5%8A%A8%E7%AB%AF%E6%B7%BB%E5%8A%A0%E4%B8%80%E6%AC%A1z-prepass/ - copyright.</description>
        </item>
    
    
    
        <item>
        <title>虚幻4移动端级联阴影ShadowMap使用率过低问题修复</title>
        <link>http://localhost:1313/post/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/ue4.22%E7%A7%BB%E5%8A%A8%E7%AB%AF%E7%BA%A7%E8%81%94%E9%98%B4%E5%BD%B1shadowmap%E4%BD%BF%E7%94%A8%E7%8E%87%E8%BF%87%E4%BD%8E%E9%97%AE%E9%A2%98%E4%BF%AE%E5%A4%8D/</link>
        <pubDate>Sat, 17 Oct 2020 22:25:32 +0800</pubDate>
        
        <guid>http://localhost:1313/post/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/ue4.22%E7%A7%BB%E5%8A%A8%E7%AB%AF%E7%BA%A7%E8%81%94%E9%98%B4%E5%BD%B1shadowmap%E4%BD%BF%E7%94%A8%E7%8E%87%E8%BF%87%E4%BD%8E%E9%97%AE%E9%A2%98%E4%BF%AE%E5%A4%8D/</guid>
        <description>月光下的旅行 http://localhost:1313/post/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/ue4.22%E7%A7%BB%E5%8A%A8%E7%AB%AF%E7%BA%A7%E8%81%94%E9%98%B4%E5%BD%B1shadowmap%E4%BD%BF%E7%94%A8%E7%8E%87%E8%BF%87%E4%BD%8E%E9%97%AE%E9%A2%98%E4%BF%AE%E5%A4%8D/ -&lt;p&gt;在微软家的这篇 [&lt;a href=&#34;https://docs.microsoft.com/zh-tw/windows/win32/dxtecharts/common-techniques-to-improve-shadow-depth-maps?redirectedfrom=MSDN&#34;&gt;Common Techniques to Improve Shadow Depth Maps&lt;/a&gt;]文章中，详细讨论Shadow Map的各种问题和解决方案，里面的摩尔纹、Peter Pan、抗锯齿等常规问题都有着详细的解决方案。在简述Shadow Camera Setup的时候，他们简单提了下Shadow Camera Fit To Scene和Fit To View的两种做法，而这两种做法区别，对ShadowMap的利用率影响非常的大。&lt;/p&gt;
&lt;p&gt;UE4内部的阴影解决方案很多，不过移动端能用上的就只有CSM。为了兼顾移动端的性能表现，设置CSM的数目 = 1就够用了，这时候的CSM实际上和单纯的Project ShadowMap算法没啥太大区别了，但是CSM数目设置为1时，UE4的阴影显得非常的淡，在人物角色上阴影表现得非常的轻浮，没有色彩感官上体现的厚重感，层次感也没体现出来，大场景时感觉还好。在人物特写的角色展示界面，这阴影质量根本不够用，emm，我记得我第一天搬下来游缘的时候滔哥就跟我说UE的阴影有问题，不过那时啥都不会天天划水（当然现在也啥都不会天天划水），过了好几个月都不想动这个阴影，直到最近几天有空了于是安排时间来解决这个问题。&lt;/p&gt;
&lt;p&gt;国庆放假回来后就开始着手解决这些问题，修改这部分的源码，一共花了大概四天时间来看引擎的CSM部分的源码，我一开始的重心是放在了阴影相机的投影矩阵构建函数上，在那里折腾了好久吧，实际上也没啥收获，不过后来在微软家的DX12 Samples里发现了Mesh Viewer实例工程，里面的Sponza阴影贴图蛮好的。而微软他们家构建投影矩阵的方式和UE4也一样，唯一不同的就是相机视锥包围盒的构建方式不同，微软他们家是写死了的。UE4使用了Fit To View的方式。&lt;/p&gt;
&lt;p&gt;UE4级联阴影Project Matrix的Setup步骤如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;根据编辑器中的CSM设置计算CSM每一级的范围距离等信息。GetShadowSplitBounds&lt;/li&gt;
&lt;li&gt;计算当前级联的视锥体包围球。GetShadowSplitBoundsDepthRange&lt;/li&gt;
&lt;li&gt;根据当前包围球范围剔除包围球外的投影体。&lt;/li&gt;
&lt;li&gt;根据包围球设置阴影相机的投影矩阵。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在上面四个步骤中，有意思的地方是步骤二的包围球计算。他们先计算了视锥的八个顶点，然后根据这八个顶点计算一个包围球。算法如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span style=&#34;color:#228b22&#34;&gt;// Calculate the ideal bounding sphere for the subfrustum.
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;// Fx  = (Db^2 - da^2) / 2Fl + Fl / 2 
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;// (where Da is the far diagonal, and Db is the near, and Fl is the frustum length)
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;float&lt;/span&gt; OptimalOffset = (DiagonalBSq - DiagonalASq) / (&lt;span style=&#34;color:#b452cd&#34;&gt;2.0f&lt;/span&gt; * FrustumLength) + FrustumLength * &lt;span style=&#34;color:#b452cd&#34;&gt;0.5f&lt;/span&gt;;
&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;float&lt;/span&gt; CentreZ = SplitFar - OptimalOffset;
CentreZ = FMath::Clamp( CentreZ, SplitNear, SplitFar );
FSphere &lt;span style=&#34;color:#008b45&#34;&gt;CascadeSphere&lt;/span&gt;(ViewOrigin + CameraDirection * CentreZ, &lt;span style=&#34;color:#b452cd&#34;&gt;0&lt;/span&gt;);
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;for&lt;/span&gt; (int32 Index = &lt;span style=&#34;color:#b452cd&#34;&gt;0&lt;/span&gt;; Index &amp;lt; &lt;span style=&#34;color:#b452cd&#34;&gt;8&lt;/span&gt;; Index++)
{
	CascadeSphere.W = FMath::Max(CascadeSphere.W, FVector::DistSquared(CascadeFrustumVerts[Index], CascadeSphere.Center));
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这种做法比直接根据八个顶点求中点然后取最大半径（一把梭的方式，我的最爱）的构建方式得到的包围球半径要小一点。&lt;/p&gt;
&lt;p&gt;Emmm，最终，问题找到了，我接下来着手把UE4的阴影相机Bounds构建方式改成了Fit To View Scene的方式（这是什么鬼方式？）。命名有点奇怪，因为我既按照Fit To View的方式构建了当前级联的视锥体，再在当前级联视锥体内构建所有Shadow Caster的Combine Bounds，最终根据原来的视锥体Bounds和后来的Shadow Caster Combine Bounds做半径比较，返回半径小的那个，这样，在投影体少的场景中，既可以利用Fit To Scene充分切合投影的优势，又可以在投影体多的场景中利用Fit To View的高利用率优势。&lt;/p&gt;
&lt;p&gt;我这里的修改实际上把 Fit To View 和 Fit To Scene都算了一遍，性能有点吃不消，profile时显示在骁龙660上每帧多花了0.12ms的cpu时间。&lt;/p&gt;
&lt;p&gt;然后15、16号游缘项目组准备搬家，这两天也是无心工作。16号下午美术部这边就剩下我一个人了，临近下班的时候正好引擎编译通过了，在RenderDoc里面测试了一切正常，现在Shadow Map利用率非常的高。&lt;/p&gt;
&lt;p&gt;另外，当场景中投影体Bounds小，但是距离离得比较远时，原始的Combine操作导致Bounds增长速度非常的快，而远处的Caster实际上并不重要，加入一个根据相机视点距离和Caster Bounds大小作为权重的有偏Combine可以有效解决这个问题。&lt;/p&gt;
&lt;p&gt;最后，对于选角、角色展示等场景，Caster很少时，我直接根据整个场景的Caster bounds来构建投影矩阵，连视锥构建都省了，快捷方便。XD。&lt;/p&gt;
- http://localhost:1313/post/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/ue4.22%E7%A7%BB%E5%8A%A8%E7%AB%AF%E7%BA%A7%E8%81%94%E9%98%B4%E5%BD%B1shadowmap%E4%BD%BF%E7%94%A8%E7%8E%87%E8%BF%87%E4%BD%8E%E9%97%AE%E9%A2%98%E4%BF%AE%E5%A4%8D/ - copyright.</description>
        </item>
    
    
    
        <item>
        <title>Substance Painter Shader与UE4移动端渲染效果同步</title>
        <link>http://localhost:1313/post/%E5%AE%9E%E6%97%B6%E6%B8%B2%E6%9F%93%E6%95%88%E6%9E%9C/substance-painter%E4%B8%8Eue4%E9%85%8D%E5%A5%97shader/</link>
        <pubDate>Sat, 26 Sep 2020 22:43:32 +0800</pubDate>
        
        <guid>http://localhost:1313/post/%E5%AE%9E%E6%97%B6%E6%B8%B2%E6%9F%93%E6%95%88%E6%9E%9C/substance-painter%E4%B8%8Eue4%E9%85%8D%E5%A5%97shader/</guid>
        <description>月光下的旅行 http://localhost:1313/post/%E5%AE%9E%E6%97%B6%E6%B8%B2%E6%9F%93%E6%95%88%E6%9E%9C/substance-painter%E4%B8%8Eue4%E9%85%8D%E5%A5%97shader/ -&lt;p&gt;要为UE4项目编写SP的Shader，首先得把MobileBasePassXXX.usf翻出来。然后将通用的直射光 漫反射+ 高光 + Skylight + IBL全拿出来，再和特殊材质如SSS、Aniso等材质编辑器中的Shader拿出来，组合一下，就完成了。&lt;/p&gt;
&lt;p&gt;参考了Substance Painter提供的示例Shader。很快就熟悉了SP的Shader编写方式。&lt;/p&gt;
&lt;p&gt;这里给个超简洁的 SP Shader示例：https://github.com/ianbanks/arma_3_substance_shader&lt;/p&gt;
&lt;p&gt;然后经过长时间的摸索和涛哥指导，SP Shader注意项：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;IBL计算必须和UE4 中的一样。绝对不能使用Substance Painter提供pbrComputeSpecular，差距非常的大，SP这个函数用了多次重要性采样积分，效果好得不得了。UE4 Mobile 的IBL就根据Roughness采样Cubemap lod，然后简单平方乘上一个亮度值，非常的搓。&lt;/li&gt;
&lt;li&gt;环境贴图使用LDR，UE4 Mobile的光照图就是LDR，HDR会相对过曝了，美术他们绘制时可能会因为HDR关系把BaseColor亮度级别拉得相对较暗，导入引擎时有差距。&lt;/li&gt;
&lt;li&gt;必须写在同一个Shader中。我一开始直接写了个模板，然后python根据输入参数不同生成不同的shader文件，比如皮肤一个，头发一个，丝绸一个。这导致模型进SP时得分开材质，导出时贴图没办法合并在一起。虽然可以在Substance Designer中合并贴图，但是SP导出时必须将填充像素减少到 1- 2。否则合并时UV岛会相交。然后这也会导致另外一个问题，合并完后UV岛边界填充少，贴图Mipmap会有texture bleeding现象，也就是远处有道缝。必须在python里再扩充一次UV岛，虽然问题最后解决了，但这美术工序越来越复杂了，最终只好全部写在一个Shader中，让美术额外绘制材质遮罩好了。&lt;/li&gt;
&lt;li&gt;ToneMapper部分也要加上去，直接写在Shader中就好了，因为调色影响很大，UE4的ToneMapper是他改过的Film函数，我直接Copy过来一个字都没改，当然需要注意改一下DX和Opengl矩阵的行列主序问题和矩阵乘法部分。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;最后记录我想出来的一个简单UV岛扩张的算法：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;计算当前贴图的黑白剪影。对黑白剪影做一次图像膨胀操作。得到扩展图。&lt;/li&gt;
&lt;li&gt;然后对黑白剪影做一次边缘检测操作，记录所有边缘的rgb值。&lt;/li&gt;
&lt;li&gt;将边缘的rgb值填充到剪影的膨胀区域上去。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;简单快速，使用python opencv库一下子就搞定了。&lt;/p&gt;
&lt;p&gt;最后：&lt;/p&gt;
&lt;p&gt;SP与UE4一直有一个奇怪的色差问题，两者的颜色饱和度区间并不相同，我坚信是IBL的差异，然后使用了同一套IBL SPECULAR后，确实减少了很多差异，但色差还是有的，我无法解决这个问题。&lt;/p&gt;
- http://localhost:1313/post/%E5%AE%9E%E6%97%B6%E6%B8%B2%E6%9F%93%E6%95%88%E6%9E%9C/substance-painter%E4%B8%8Eue4%E9%85%8D%E5%A5%97shader/ - copyright.</description>
        </item>
    
    
    
        <item>
        <title>各向异性材质渲染与美术流程注意事项</title>
        <link>http://localhost:1313/post/%E5%AE%9E%E6%97%B6%E6%B8%B2%E6%9F%93%E6%95%88%E6%9E%9C/%E4%B8%9D%E7%BB%B8%E5%A4%B4%E5%8F%91%E5%90%84%E5%90%91%E5%BC%82%E6%80%A7%E6%9D%90%E8%B4%A8%E6%B8%B2%E6%9F%93%E4%B8%8E%E7%BE%8E%E6%9C%AF%E5%88%B6%E4%BD%9C%E6%B5%81%E7%A8%8B%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/</link>
        <pubDate>Wed, 08 Jul 2020 21:23:32 +0800</pubDate>
        
        <guid>http://localhost:1313/post/%E5%AE%9E%E6%97%B6%E6%B8%B2%E6%9F%93%E6%95%88%E6%9E%9C/%E4%B8%9D%E7%BB%B8%E5%A4%B4%E5%8F%91%E5%90%84%E5%90%91%E5%BC%82%E6%80%A7%E6%9D%90%E8%B4%A8%E6%B8%B2%E6%9F%93%E4%B8%8E%E7%BE%8E%E6%9C%AF%E5%88%B6%E4%BD%9C%E6%B5%81%E7%A8%8B%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/</guid>
        <description>月光下的旅行 http://localhost:1313/post/%E5%AE%9E%E6%97%B6%E6%B8%B2%E6%9F%93%E6%95%88%E6%9E%9C/%E4%B8%9D%E7%BB%B8%E5%A4%B4%E5%8F%91%E5%90%84%E5%90%91%E5%BC%82%E6%80%A7%E6%9D%90%E8%B4%A8%E6%B8%B2%E6%9F%93%E4%B8%8E%E7%BE%8E%E6%9C%AF%E5%88%B6%E4%BD%9C%E6%B5%81%E7%A8%8B%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/ -&lt;h2 id=&#34;原理&#34;&gt;原理&lt;/h2&gt;
&lt;p&gt;丝绸、头发这些各项异性材质，它们的高光部分计算使用的是各向异性方式。当然实时渲染里不可能像离线渲染里那样去积分计算，游戏中大部分都是用切线代替法线来近似计算各向异性高光。&lt;/p&gt;
&lt;p&gt;然后高光的计算方式主要有三种，一个是Kaijya-Kay模型，它主要用在头发高光计算上。&lt;/p&gt;
&lt;p&gt;Kaijya-Kay的高光计算方式：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/%E4%B8%9D%E7%BB%B8%E3%80%81%E5%A4%B4%E5%8F%91%E5%90%84%E5%90%91%E5%BC%82%E6%80%A7%E6%9D%90%E8%B4%A8%E6%B8%B2%E6%9F%93%E4%B8%8E%E7%BE%8E%E6%9C%AF%E5%88%B6%E4%BD%9C%E6%B5%81%E7%A8%8B%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9.assets/Image.png&#34; alt=&#34;Image&#34;&gt;&lt;/p&gt;
&lt;p&gt;它不再使用法线点积半角向量了，而是直接使用切线向量与半角向量的夹角的余弦值作为高光系数。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/%E4%B8%9D%E7%BB%B8%E3%80%81%E5%A4%B4%E5%8F%91%E5%90%84%E5%90%91%E5%BC%82%E6%80%A7%E6%9D%90%E8%B4%A8%E6%B8%B2%E6%9F%93%E4%B8%8E%E7%BE%8E%E6%9C%AF%E5%88%B6%E4%BD%9C%E6%B5%81%E7%A8%8B%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9.assets/Image-1604592907560.png&#34; alt=&#34;Image&#34;&gt;&lt;/p&gt;
&lt;p&gt;于是，当半角向量H与切线方向T夹角在[0,90°]时，按照正弦函数，夹角越小，得到的高光系数越小，然后幂乘后得到的高光值越小，然后当视线在发丝的落点沿着切线方向向发根平移时，H与T的夹角将会变大，高光值将会渐渐增大，从而形成头发顶部高光的感觉。&lt;/p&gt;
&lt;p&gt;当然现在没有头发高光流动的感觉，为了模拟高光流动，它将切线沿着法线方向作偏移。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/%E4%B8%9D%E7%BB%B8%E3%80%81%E5%A4%B4%E5%8F%91%E5%90%84%E5%90%91%E5%BC%82%E6%80%A7%E6%9D%90%E8%B4%A8%E6%B8%B2%E6%9F%93%E4%B8%8E%E7%BE%8E%E6%9C%AF%E5%88%B6%E4%BD%9C%E6%B5%81%E7%A8%8B%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9.assets/Image-1604592928759.png&#34; alt=&#34;Image&#34;&gt;&lt;/p&gt;
&lt;p&gt;也就是这样：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;half3 &lt;span style=&#34;color:#008b45&#34;&gt;ShiftedTangent&lt;/span&gt;(float3 t, float3 n, &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;float&lt;/span&gt; shift) {
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; normalize(t + shift * n);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;然后这个shift值一般采样一个偏移量灰度图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/%E4%B8%9D%E7%BB%B8%E3%80%81%E5%A4%B4%E5%8F%91%E5%90%84%E5%90%91%E5%BC%82%E6%80%A7%E6%9D%90%E8%B4%A8%E6%B8%B2%E6%9F%93%E4%B8%8E%E7%BE%8E%E6%9C%AF%E5%88%B6%E4%BD%9C%E6%B5%81%E7%A8%8B%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9.assets/Image-1604592958781.png&#34; alt=&#34;Image&#34;&gt;&lt;/p&gt;
&lt;p&gt;这种灰度图可以在PS里用一个白噪声 + v方向的运动模糊生成。&lt;/p&gt;
&lt;p&gt;当前shift值是[0,1]范围，将它作如下处理，使得高光可以随机向上向下流动:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;float&lt;/span&gt; shift = tex2D(shitTex,uv).x - &lt;span style=&#34;color:#b452cd&#34;&gt;0.5f&lt;/span&gt;;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;最后是高光计算：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-C++&#34; data-lang=&#34;C++&#34;&gt;&lt;span style=&#34;color:#228b22&#34;&gt;// T 为发丝切线方向，V为视线方向，L为灯光方向，exponent为高光幂指数
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;float&lt;/span&gt; &lt;span style=&#34;color:#008b45&#34;&gt;StrandSpecular&lt;/span&gt;(float3 T, float3 V, float3 L, &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; exponent)
{
    float3 H = normalize(L + V);
    &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;float&lt;/span&gt; dotTH = dot(T, H);
    &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;float&lt;/span&gt; sinTH = sqrt(&lt;span style=&#34;color:#b452cd&#34;&gt;1.0&lt;/span&gt; - dotTH * dotTH);
    &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;float&lt;/span&gt; dirAtten = smoothstep(-&lt;span style=&#34;color:#b452cd&#34;&gt;1&lt;/span&gt;, &lt;span style=&#34;color:#b452cd&#34;&gt;0&lt;/span&gt;, dotTH);
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; dirAtten * pow(sinTH, exponent);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这里的dirAtten主要是处理T与H夹角余弦落在[-1,0]之间，给一个高光值的衰减，处理视角向量与发丝切线接近重合时高光值异常问题。可以把它去掉来做一次比较，发现有方向衰减和没方向衰减的高光差异极大。&lt;/p&gt;
&lt;p&gt;另外高光计算方式可以换成GGX各向异性法线函数，或者是Ward各向异性函数法线函数，它们和Kaijya-Kay类似，只不过Kaijya-Kay为了实现向上向下两层高光偏移，需要计算两次高光：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;float&lt;/span&gt; shift1 = tex2D(shitTex,uv).x * _flatshift + _SpecShift;
&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;float&lt;/span&gt; shift2 = tex2D(shitTex,uv).x * _flatshift + _SpecShift + _SpecShift2;
float3 T1 = ShiftTangent( tan , Wnormal , shift1);
float3 T2 = ShiftTangent( tan , Wnormal , shift2);
float3 spec1 = StrandSpecular(T1,...) * _SpecColor * _AnisoSpecular;
float3 spec2 = StrandSpecular(T2,...) * _SpecColor2 * _AnisoSpecular * &lt;span style=&#34;color:#b452cd&#34;&gt;0.6&lt;/span&gt;;
float3 spec = spec1+spec2;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这是很耗费性能的，因为使用了幂乘，而且有时候会为了压制高光的强度把幂乘指数调得很高，还算了两次。&lt;/p&gt;
&lt;p&gt;Kaijya-Kay整体的着色器如下，注意它的漫反射着色使用插值的Normal dot Light：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-C++&#34; data-lang=&#34;C++&#34;&gt;float4 &lt;span style=&#34;color:#008b45&#34;&gt;HairLighting&lt;/span&gt; (float3 tangent, float3 normal, float3 lightVec,
                     float3 viewVec, float2 uv, &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;float&lt;/span&gt; ambOcc)
{
    &lt;span style=&#34;color:#228b22&#34;&gt;// shift tangents
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;float&lt;/span&gt; shiftTex = tex2D(tSpecShift, uv) - &lt;span style=&#34;color:#b452cd&#34;&gt;0.5&lt;/span&gt;;


    float3 t1 = ShiftTangent(tangent, normal, primaryShift + shiftTex);
    float3 t2 = ShiftTangent(tangent, normal, secondaryShift + shiftTex);


    &lt;span style=&#34;color:#228b22&#34;&gt;// diffuse lighting
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;    float3 diffuse = saturate(lerp(&lt;span style=&#34;color:#b452cd&#34;&gt;0.25&lt;/span&gt;, &lt;span style=&#34;color:#b452cd&#34;&gt;1.0&lt;/span&gt;, dot(normal, lightVec)));


    &lt;span style=&#34;color:#228b22&#34;&gt;// specular lighting
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;    float3 specular = specularColor1 * StrandSpecular(t1, viewVec, lightVec, specExp1);


    &lt;span style=&#34;color:#228b22&#34;&gt;// add second specular term
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;float&lt;/span&gt; specMask = tex2D(tSpecMask, uv);
    specular += specularColor2 * specMask * StrandSpecular(t2, viewVec, lightVec, specExp2);


    &lt;span style=&#34;color:#228b22&#34;&gt;// Final color
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;    float4 o;
    o.rgb = (diffuse + specular) * tex2D(tBase, uv) * lightColor;
    o.rgb *= ambOcc;
    o.a = tex2D(tAlpha, uv);
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; o;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;相比之下，GGX各向异性比较省性能，它的计算方式直接传入X，Y方向的粗糙度值，高光计算一次算完，而且最重要的是没有幂乘，性能卓越：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;float&lt;/span&gt; &lt;span style=&#34;color:#008b45&#34;&gt;D_GGXaniso&lt;/span&gt;( &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;float&lt;/span&gt; RoughnessX,&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;float&lt;/span&gt; RoughnessY,&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;float&lt;/span&gt; NoH,float3 H, float3 X, float3 Y)
{
    &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;float&lt;/span&gt; ax = RoughnessX * RoughnessX;
    &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;float&lt;/span&gt; ay = RoughnessY * RoughnessY;
    &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;float&lt;/span&gt; XoH = dot( X, H );
    &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;float&lt;/span&gt; YoH = dot( Y, H );
    &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;float&lt;/span&gt; d = XoH*XoH / (ax*ax) + YoH*YoH / (ay*ay) + NoH*NoH;
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#b452cd&#34;&gt;1&lt;/span&gt; / ( pi * ax*ay * d*d );
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;而Ward各向异性函数法线函数，大同小异：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-C++&#34; data-lang=&#34;C++&#34;&gt;&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;float&lt;/span&gt; &lt;span style=&#34;color:#008b45&#34;&gt;sqr&lt;/span&gt;(&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;float&lt;/span&gt; x) {
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; x * x;
}


&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;float&lt;/span&gt; &lt;span style=&#34;color:#008b45&#34;&gt;WardAnisotropicNormalDistribution&lt;/span&gt;(&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;float&lt;/span&gt; anisotropic, &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;float&lt;/span&gt; NdotL, &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;float&lt;/span&gt; NdotV,
&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;float&lt;/span&gt; NdotH, &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;float&lt;/span&gt; HdotX, &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;float&lt;/span&gt; HdotY)
{
    &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;float&lt;/span&gt; aspect = sqrt(&lt;span style=&#34;color:#b452cd&#34;&gt;1.0&lt;/span&gt;h - anisotropic * &lt;span style=&#34;color:#b452cd&#34;&gt;0.9&lt;/span&gt;h);
    &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;float&lt;/span&gt; roughnessSqr = (&lt;span style=&#34;color:#b452cd&#34;&gt;1&lt;/span&gt; - &lt;span style=&#34;color:#b452cd&#34;&gt;0.5&lt;/span&gt;);
    roughnessSqr *= roughnessSqr;
    &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;float&lt;/span&gt; X = roughnessSqr / aspect;
    &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;float&lt;/span&gt; Y = roughnessSqr * aspect;
    &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;float&lt;/span&gt; exponent = -(sqr(HdotX / X) + sqr(HdotY / Y)) / sqr(NdotH);
    &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;float&lt;/span&gt; Distribution = &lt;span style=&#34;color:#b452cd&#34;&gt;1.0&lt;/span&gt; / (&lt;span style=&#34;color:#b452cd&#34;&gt;4.0&lt;/span&gt; * &lt;span style=&#34;color:#b452cd&#34;&gt;3.14159265&lt;/span&gt; * X * Y * sqrt(NdotL * NdotV));
    Distribution *= exp(exponent);
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; Distribution;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;高光部分算完之后，直接叠加一个漫反射光就行了，使用普通的兰伯特模型就能得到不错的漫反射结果了，然后丝绸渲染往往会有一个色调映射，加一个颜色的lerp来统一最终的色调。&lt;/p&gt;
&lt;p&gt;以上这些基本就是全部的原理。&lt;/p&gt;
&lt;h2 id=&#34;美术制作注意事项&#34;&gt;美术制作注意事项&lt;/h2&gt;
&lt;p&gt;然后才是最重要的美术制作环节。&lt;/p&gt;
&lt;p&gt;各向异性材质计算使用到了切线和副切线，而切线的方向对应模型的uv的u方向，副切线方向对应模型UV的V方向，切线算法有mikktspace和经典的xNormal等，比较简单的切线与副切线的计算方法如下,来自gamedev论坛的&lt;a href=&#34;https://gamedev.stackexchange.com/questions/68612/how-to-compute-tangent-and-bitangent-vectors&#34;&gt;回答&lt;/a&gt;：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/%E4%B8%9D%E7%BB%B8%E3%80%81%E5%A4%B4%E5%8F%91%E5%90%84%E5%90%91%E5%BC%82%E6%80%A7%E6%9D%90%E8%B4%A8%E6%B8%B2%E6%9F%93%E4%B8%8E%E7%BE%8E%E6%9C%AF%E5%88%B6%E4%BD%9C%E6%B5%81%E7%A8%8B%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9.assets/Image-1604593146911.png&#34; alt=&#34;Image&#34;&gt;&lt;/p&gt;
&lt;p&gt;其中：  &lt;br&gt;
$$
E1 = (u1-u0)T + (v1-v0)B&lt;/p&gt;
&lt;p&gt;$$&lt;/p&gt;
&lt;p&gt;$$
E2 = (u2-u0)T + (v2-v0)B
$$&lt;/p&gt;
&lt;p&gt;两个等式，两个未知量，因此：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;| E1x E1y E1z |   | deltaU1 deltaV1 | * | Tx Ty Tz |
| E2x E2y E2z | = | deltaU2 deltaV2 |   | Bx By Bz |
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;转化为C++代码:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;struct&lt;/span&gt; &lt;span style=&#34;color:#008b45;font-weight:bold&#34;&gt;Triangle&lt;/span&gt;
{
    &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;unsigned&lt;/span&gt; &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;short&lt;/span&gt;  index[&lt;span style=&#34;color:#b452cd&#34;&gt;3&lt;/span&gt;];
};


&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#008b45&#34;&gt;CalculateTangentArray&lt;/span&gt;(&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;long&lt;/span&gt; vertexCount, &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;const&lt;/span&gt; Point3D *vertex, &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;const&lt;/span&gt; Vector3D *normal,
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;const&lt;/span&gt; Point2D *texcoord, &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;long&lt;/span&gt; triangleCount, &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;const&lt;/span&gt; Triangle *triangle, Vector4D *tangent)
{
    Vector3D *tan1 = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;new&lt;/span&gt; Vector3D[vertexCount * &lt;span style=&#34;color:#b452cd&#34;&gt;2&lt;/span&gt;];
    Vector3D *tan2 = tan1 + vertexCount;
    ZeroMemory(tan1, vertexCount * &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;sizeof&lt;/span&gt;(Vector3D) * &lt;span style=&#34;color:#b452cd&#34;&gt;2&lt;/span&gt;);
    
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;long&lt;/span&gt; a = &lt;span style=&#34;color:#b452cd&#34;&gt;0&lt;/span&gt;; a &amp;lt; triangleCount; a++)
    {
        &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;long&lt;/span&gt; i1 = triangle-&amp;gt;index[&lt;span style=&#34;color:#b452cd&#34;&gt;0&lt;/span&gt;];
        &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;long&lt;/span&gt; i2 = triangle-&amp;gt;index[&lt;span style=&#34;color:#b452cd&#34;&gt;1&lt;/span&gt;];
        &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;long&lt;/span&gt; i3 = triangle-&amp;gt;index[&lt;span style=&#34;color:#b452cd&#34;&gt;2&lt;/span&gt;];


        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;const&lt;/span&gt; Point3D&amp;amp; v1 = vertex[i1];
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;const&lt;/span&gt; Point3D&amp;amp; v2 = vertex[i2];
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;const&lt;/span&gt; Point3D&amp;amp; v3 = vertex[i3];
        
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;const&lt;/span&gt; Point2D&amp;amp; w1 = texcoord[i1];
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;const&lt;/span&gt; Point2D&amp;amp; w2 = texcoord[i2];
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;const&lt;/span&gt; Point2D&amp;amp; w3 = texcoord[i3];
        
        &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;float&lt;/span&gt; x1 = v2.x - v1.x;
        &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;float&lt;/span&gt; x2 = v3.x - v1.x;
        &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;float&lt;/span&gt; y1 = v2.y - v1.y;
        &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;float&lt;/span&gt; y2 = v3.y - v1.y;
        &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;float&lt;/span&gt; z1 = v2.z - v1.z;
        &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;float&lt;/span&gt; z2 = v3.z - v1.z;
        
        &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;float&lt;/span&gt; s1 = w2.x - w1.x;
        &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;float&lt;/span&gt; s2 = w3.x - w1.x;
        &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;float&lt;/span&gt; t1 = w2.y - w1.y;
        &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;float&lt;/span&gt; t2 = w3.y - w1.y;
        
        &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;float&lt;/span&gt; r = &lt;span style=&#34;color:#b452cd&#34;&gt;1.0F&lt;/span&gt; / (s1 * t2 - s2 * t1);
        Vector3D sdir((t2 * x1 - t1 * x2) * r, (t2 * y1 - t1 * y2) * r,
                (t2 * z1 - t1 * z2) * r);
        Vector3D tdir((s1 * x2 - s2 * x1) * r, (s1 * y2 - s2 * y1) * r,
                (s1 * z2 - s2 * z1) * r);
        
        tan1[i1] += sdir;
        tan1[i2] += sdir;
        tan1[i3] += sdir;
        
        tan2[i1] += tdir;
        tan2[i2] += tdir;
        tan2[i3] += tdir;
        
        triangle++;
    }
    
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;long&lt;/span&gt; a = &lt;span style=&#34;color:#b452cd&#34;&gt;0&lt;/span&gt;; a &amp;lt; vertexCount; a++)
    {
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;const&lt;/span&gt; Vector3D&amp;amp; n = normal[a];
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;const&lt;/span&gt; Vector3D&amp;amp; t = tan1[a];
        
        &lt;span style=&#34;color:#228b22&#34;&gt;// Gram-Schmidt orthogonalize
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;        tangent[a] = (t - n * Dot(n, t)).Normalize();
        
        &lt;span style=&#34;color:#228b22&#34;&gt;// Calculate handedness
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;        tangent[a].w = (Dot(Cross(n, t), tan2[a]) &amp;lt; &lt;span style=&#34;color:#b452cd&#34;&gt;0.0F&lt;/span&gt;) ? -&lt;span style=&#34;color:#b452cd&#34;&gt;1.0F&lt;/span&gt; : &lt;span style=&#34;color:#b452cd&#34;&gt;1.0F&lt;/span&gt;;
    }
    
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;delete&lt;/span&gt;[] tan1;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;总结切线/副切线的主要计算步骤如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;遍历所有三角形顶点，每个顶点算一次切线t1 和副切线t2，然后累加存储起来。&lt;/li&gt;
&lt;li&gt;Gram-Schmidt方法构造render space（local space）的Tangent。&lt;/li&gt;
&lt;li&gt;叉积顶点normal，得到的结果再点积副切线t2，判断符号w。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;当然如果一个顶点是UV镜像分界上的点，那么它会分裂成两个点，分别存储w = -1 ，+1，然后传入顶点着色器。&lt;/p&gt;
&lt;p&gt;那么知道了切线和副切线的计算方式后，首先要明确一点：模型uv的切线方向(u)是否为头发发丝生长方向？如果是U方向发丝，那么直接使用上述方式计算就好了。&lt;/p&gt;
&lt;p&gt;美术在制作模型的时候，为了方便往往发丝的UV是按V向展开的，这时候，头发生长方向与副切线方向相同，计算高光的时候，使用的应该就是副切线来计算高光。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span style=&#34;color:#228b22&#34;&gt;// 按U向生长
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;half3 T = normalize(s.tangent_input); &lt;span style=&#34;color:#228b22&#34;&gt;// 注意光栅化为线性插值
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;

&lt;span style=&#34;color:#228b22&#34;&gt;// 按V向生长
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;half3 T = -normalize(cross( s.Normal, s.tangent_input));
        
&lt;span style=&#34;color:#228b22&#34;&gt;// 计算高光
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;StrandSpecular(T,...);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;美术往往会为了方便，在制作模型的时候使用镜像UV，不过没关系，无论是按照U镜像，还是V镜像，它们都会导致切线叉积副切线后得到的法线与顶点法线的点积结果分别为-1，+1，而在计算切线的时候，根据切线与副切线叉积后与法线的点积结果的符号，决定存入模型顶点的tangent.w = -1 还是 +1，那么在构建TBN矩阵的时候，乘上这个，它将根据镜像uv与否分别构建左右手坐标系：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;float3 world_tangent = cross(world_normal,world_tangent) * vertex.tangent.w;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;在UE4中，在Custom节点，生成的函数里传入的Parameters参数结构体中，有一个UnMirrored值，它等同于Unity的tangent.w。   如果不愿意让UV严格沿着U或V方向排布，那么一般会绘制一张切线空间的切线图作为发丝切线的方向控制，计算的时候直接采样这个切线图的切线，然后再从切线空间中转换到世界空间下，再参与高光计算。&lt;/p&gt;
&lt;p&gt;如果顶点中存了副切线（比如存储在顶点色中），那么也可以将切线空间采样到的向量转换到local空间（渲染空间）下，再根据世界空间法线用Gram-Schmidt方式转化为世界空间下切线，然后再构建一个TBN矩阵：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;vector_localspace =   vector_tangentspace.x * vertex.Tangent +
                        vector_tangentspace.y * vertex.Bitangent +
                        vector_tangentspace.z * vertex.Normal;


vector_worldspace = vector_localspace - world_normal*dot(vector_localspace, world_normal);
vector_worldspace = normalize(vector_worldspace);
float3 binormal = cross(normal_world,vector_)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;当然，对于按V方向镜像的模型，拿到了切线空间切线图后，也需要转化为副切线来参与高光运算：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;tangent_input = UnpackNormal( tex2D(_CombTex, IN.uv_MainTex));
&lt;span style=&#34;color:#228b22&#34;&gt;//...
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;转化的时候需要注意，因为UV镜像，特别是V镜像，在镜像接缝处，如果不对切线做特殊处理，绝对会形成一个明显的接缝。&lt;/p&gt;
&lt;p&gt;切线特殊处理是什么呢？就我探索的，找到接缝处，将它的切线方向摆成直线，这样，左右手系叉积出来的副切线绝对重合。&lt;/p&gt;
&lt;p&gt;那么如何找到接缝处呢，直接遍历所有的w = -1顶点，然后根据每个w = -1的顶点，遍历所有 w = 1的顶点，如果在w = 1的顶点中，找到对称点，那么它就不是接缝点，否则它就是接缝点，然后摆直接缝点的切线。&lt;/p&gt;
&lt;p&gt;如何摆直？我根据上述公式推测，当v镜像时，如果不镜像，那么tangent需要乘上（1，-1，-1），w保持不变。&lt;/p&gt;
&lt;h2 id=&#34;头发的半透明排序混合&#34;&gt;头发的半透明排序混合&lt;/h2&gt;
&lt;p&gt;在前面提到的GDC PPT分享中，里面还给出了头发近似深度方式。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;为了正确的进行alpha-blending，按照从后向前顺序进行绘制。&lt;/li&gt;
&lt;li&gt;头发绘制顺序也是由内向外。&lt;/li&gt;
&lt;li&gt;解决方法是预先计算一个静态index buffer。&lt;/li&gt;
&lt;li&gt;排序连接的组件(发丝贴片)而不是单个三角形&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/%E4%B8%9D%E7%BB%B8%E3%80%81%E5%A4%B4%E5%8F%91%E5%90%84%E5%90%91%E5%BC%82%E6%80%A7%E6%9D%90%E8%B4%A8%E6%B8%B2%E6%9F%93%E4%B8%8E%E7%BE%8E%E6%9C%AF%E5%88%B6%E4%BD%9C%E6%B5%81%E7%A8%8B%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9.assets/Image-1604593419284.png&#34; alt=&#34;Image&#34;&gt;&lt;/p&gt;
&lt;p&gt;实现思路也比较简单，先按照头发贴片的排序顺序，从里到外绘制。在Unity中可以直接根据贴片里外顺序建立一个静态的DrawIndex数组，然后在CommandBuffer中手动调用按从里到外顺序渲染即可，UE4中比较麻烦，事实上我还没在UE4中实现过。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/%E4%B8%9D%E7%BB%B8%E3%80%81%E5%A4%B4%E5%8F%91%E5%90%84%E5%90%91%E5%BC%82%E6%80%A7%E6%9D%90%E8%B4%A8%E6%B8%B2%E6%9F%93%E4%B8%8E%E7%BE%8E%E6%9C%AF%E5%88%B6%E4%BD%9C%E6%B5%81%E7%A8%8B%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9.assets/Image-1604593431337.png&#34; alt=&#34;Image&#34;&gt;&lt;/p&gt;
&lt;p&gt;PPT给出的最终的渲染顺序如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Pass 1 - prime Z buffer启用alpha test，仅仅通过不透明的像素Cull Off启用Z writes, 设置Z test为Lessban color buffer writespixel shader 只写入alpha值&lt;/li&gt;
&lt;li&gt;Pass 2 - 不透明部分Cull Back Off禁用Z writes, 设置Z test为Equal&lt;/li&gt;
&lt;li&gt;Pass 3 - 透明背面部分Cull Front禁用Z writes, 设置Z test为Less&lt;/li&gt;
&lt;li&gt;Pass 4 -透明前面部分Cull Back启用Z writes, 设置Z test为Less&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;与常规渲染比较，先绘制一遍简单的Prime Z buffer，把头发不透明部分的深度都写入进去，然后在第二遍Pass中绘制不透明的部分，仅当Z Depth等于最小值时才执行绘制pixel shader，并且第二部分Pass没有alpha test，执行了一次Early-Z，不通过Z test的片元着色器没有执行，大大减少了Overdraw。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;然后透明部分就是从内到外的绘制了，注意绘制背面的时候不用写入Z，因为背面的Z永远是大于前面的，不如关闭写入节约性能，但开启Z test，然后可以检测是否被不透明物体遮挡住了，被遮住了直接不画了，而且这部分也没有alpha test，执行Early-Z。&lt;/p&gt;
&lt;p&gt;绘制头发前面的时候开启Z Write，将前面作为头发的最终深度，这个Pass也有Early-Z。    实际项目中，如果头发的背面不需要显示，比如远处的人物，可以直接关闭Pass3，省下性能。&lt;/p&gt;
- http://localhost:1313/post/%E5%AE%9E%E6%97%B6%E6%B8%B2%E6%9F%93%E6%95%88%E6%9E%9C/%E4%B8%9D%E7%BB%B8%E5%A4%B4%E5%8F%91%E5%90%84%E5%90%91%E5%BC%82%E6%80%A7%E6%9D%90%E8%B4%A8%E6%B8%B2%E6%9F%93%E4%B8%8E%E7%BE%8E%E6%9C%AF%E5%88%B6%E4%BD%9C%E6%B5%81%E7%A8%8B%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/ - copyright.</description>
        </item>
    
    
    
        <item>
        <title>简单翻页效果</title>
        <link>http://localhost:1313/post/%E5%AE%9E%E6%97%B6%E6%B8%B2%E6%9F%93%E6%95%88%E6%9E%9C/%E7%AE%80%E6%98%93%E7%BF%BB%E9%A1%B5%E6%95%88%E6%9E%9C%E5%AE%9E%E7%8E%B0/</link>
        <pubDate>Fri, 03 Jul 2020 21:25:32 +0800</pubDate>
        
        <guid>http://localhost:1313/post/%E5%AE%9E%E6%97%B6%E6%B8%B2%E6%9F%93%E6%95%88%E6%9E%9C/%E7%AE%80%E6%98%93%E7%BF%BB%E9%A1%B5%E6%95%88%E6%9E%9C%E5%AE%9E%E7%8E%B0/</guid>
        <description>月光下的旅行 http://localhost:1313/post/%E5%AE%9E%E6%97%B6%E6%B8%B2%E6%9F%93%E6%95%88%E6%9E%9C/%E7%AE%80%E6%98%93%E7%BF%BB%E9%A1%B5%E6%95%88%E6%9E%9C%E5%AE%9E%E7%8E%B0/ -&lt;p&gt;翻页效果主要分为顶点着色器动画和UI遮罩动画。我简单的在Unity上分别实现这两个，然后移植到UE4上面去。&lt;/p&gt;
&lt;h2 id=&#34;顶点着色器动画&#34;&gt;顶点着色器动画&lt;/h2&gt;
&lt;p&gt;顶点着色器实现实际上就是网格顶点变形动画，片元着色器就是简单的采样纹理着色，注意正面与背面的区别，重点在于顶点着色器，它的工作内容可以分为两大部分：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;顶点翻页变形，选择合适的圆锥曲线或者正弦曲线函数做顶点变化。&lt;/li&gt;
&lt;li&gt;将顶点绕轴旋转合适的角度。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;我首先实现步骤2，然后再实现步骤1。&lt;/p&gt;
&lt;p&gt;首先是&lt;strong&gt;将顶点绕轴旋转合适的角度&lt;/strong&gt;，输入是当前页面的旋转角度，然后将所有的顶点绕着装订轴旋转该角度。&lt;/p&gt;
&lt;p&gt;输入模型是一个平面模型，10 * 10的平面网格，默认中心点在原点，因此需要将所有顶点都平移一段距离，使得旋转中心轴线在网格的左边或者右边。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span style=&#34;color:#228b22&#34;&gt;// 旋转前将所有顶点移动到装订线处
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;v.vertex.x -= _PinLine;
&lt;span style=&#34;color:#228b22&#34;&gt;// 在这里旋转所有顶点
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;// 旋转后再移动回原位置
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;v.vertex.x += _PinLine;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;然后旋转部分是绕z轴旋转，旋转矩阵为：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/%E7%AE%80%E6%98%93%E7%BF%BB%E9%A1%B5%E6%95%88%E6%9E%9C%E5%AE%9E%E7%8E%B0.assets/Image.png&#34; alt=&#34;Image&#34;&gt;&lt;/p&gt;
&lt;p&gt;转换为代码是：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span style=&#34;color:#228b22&#34;&gt;// 绕z轴旋转
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;float&lt;/span&gt; angle_rad = radians(-_Angle);
&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;float&lt;/span&gt; s;&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;float&lt;/span&gt; c;sincos(angle_rad,s,c);
float2 rotate_ret = v.vertex.xy;
v.vertex.x = rotate_ret.x * c + rotate_ret.y * s;
v.vertex.y = rotate_ret.y * c - rotate_ret.x * s;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;我这里把矩阵展开了，实际上是一样的效果。&lt;/p&gt;
&lt;p&gt;现在实现平面网格沿着z轴旋转的效果了。&lt;/p&gt;
&lt;p&gt;接下来加上顶点的变形。&lt;/p&gt;
&lt;p&gt;根据你选择数学函数的不同，顶点变形的效果也会呈现不同的形状，简单的有正弦曲面函数，复杂的有圆锥曲面函数，也可以用多个频率的正弦曲面函数叠加得到一个好看的形状，我这里试了正弦函数和圆锥曲面函数：&lt;/p&gt;
&lt;p&gt;首先是正弦函数：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span style=&#34;color:#228b22&#34;&gt;// 在这里执行顶点变形动画
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;float&lt;/span&gt; factor = saturate(&lt;span style=&#34;color:#b452cd&#34;&gt;1&lt;/span&gt; - abs(&lt;span style=&#34;color:#b452cd&#34;&gt;90&lt;/span&gt; - _Angle) / &lt;span style=&#34;color:#b452cd&#34;&gt;90&lt;/span&gt;);
v.vertex.y -= _Factor * sin(v.vertex.x * &lt;span style=&#34;color:#b452cd&#34;&gt;0.4f&lt;/span&gt; - _FactorY * v.vertex.x) * factor;
v.vertex.x -= v.vertex.x * factor * _FactorX;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这里直接根据 y = sin(nx) 来计算函数曲线。得到的翻页曲面也是正弦形状的。&lt;/p&gt;
&lt;p&gt;我还添加了系数控制的FactorX 和 FactorY 以及总的y变形系数，便于自定义变形效果。&lt;/p&gt;
&lt;p&gt;得到的翻页效果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/%E7%AE%80%E6%98%93%E7%BF%BB%E9%A1%B5%E6%95%88%E6%9E%9C%E5%AE%9E%E7%8E%B0.assets/Image-1604592286507.png&#34; alt=&#34;Image&#34;&gt;&lt;/p&gt;
&lt;p&gt;多页面叠加时可能会有Z-Fighting，这里在前页面Pass渲染时添加上一个Offset来避免。&lt;/p&gt;
&lt;p&gt;注：关于这个Offset，我查到的资料有：&lt;/p&gt;
&lt;p&gt;Unity论坛：    &lt;a href=&#34;https://forum.unity3d.com/threads/offset-parameters.23281/&#34;&gt;https://forum.unity3d.com/threads/offset-parameters.23281/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;或者KH组的解释：    &lt;a href=&#34;https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glPolygonOffset.xhtml&#34;&gt;https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glPolygonOffset.xhtml&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;也就是绘制时，每一个片元的深度值都会增加一个偏移量offset，它的计算方式：
$$
offset = (m * factor) + (r * units)
$$
其中，m是多边形各边深度的斜率中的最大值，它在光栅化阶段计算得到。在光栅化阶段，若一个多边形越是与近裁剪面平行，每个边的深度变化越接近0，m就越接近0。r是NDC空间下的最小深度单位，它是图形Api设置的。&lt;/p&gt;
&lt;p&gt;m的详细计算公式如下：https://www.inf.ufes.br/~thomas/graphics/OpenGL/docs/glspec1.1/node58.html    核心步骤为：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/%E7%AE%80%E6%98%93%E7%BF%BB%E9%A1%B5%E6%95%88%E6%9E%9C%E5%AE%9E%E7%8E%B0.assets/Image-1604592368801.png&#34; alt=&#34;Image&#34;&gt;&lt;/p&gt;
&lt;p&gt;一个大于0 的 offset 会把模型推更远一点的位置，一个小于0的offset 会把模型拉近。&lt;/p&gt;
&lt;p&gt;Unity Shader的Offset有两个参数，第一个是因子factor，第二个是单位units。&lt;/p&gt;
&lt;p&gt;渲染页面时，为避免与其他重叠页面产生z-fight，于是使用Offset，我这里想让Offset 按照多边形的深度斜率变化递增，并且最少offset一个单位的深度，所以设: Offset -1,-1    当前完整的Shader代码如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-C++&#34; data-lang=&#34;C++&#34;&gt;Shader &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;GraphicsLibrary/FlipPaper/SineFlip&amp;#34;&lt;/span&gt;
{
    Properties
    {
        _FrontPage (&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;Page Front&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#b452cd&#34;&gt;2&lt;/span&gt;D) = &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;white&amp;#34;&lt;/span&gt; {}
        _BackPage  (&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;Page Back&amp;#34;&lt;/span&gt; , &lt;span style=&#34;color:#b452cd&#34;&gt;2&lt;/span&gt;D) = &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;white&amp;#34;&lt;/span&gt; {}
        _Angle (&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;Curl Angle&amp;#34;&lt;/span&gt;, Range(&lt;span style=&#34;color:#b452cd&#34;&gt;0&lt;/span&gt;,&lt;span style=&#34;color:#b452cd&#34;&gt;180&lt;/span&gt;)) = &lt;span style=&#34;color:#b452cd&#34;&gt;0&lt;/span&gt;
        _PinLine (&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;Pin Line&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;float&lt;/span&gt;) = &lt;span style=&#34;color:#b452cd&#34;&gt;0&lt;/span&gt;
        _Amount(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;Amount&amp;#34;&lt;/span&gt;,Range(&lt;span style=&#34;color:#b452cd&#34;&gt;0&lt;/span&gt;,&lt;span style=&#34;color:#b452cd&#34;&gt;2&lt;/span&gt;)) = &lt;span style=&#34;color:#b452cd&#34;&gt;0&lt;/span&gt;
        _FactorX(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;Factor X&amp;#34;&lt;/span&gt;,Range(&lt;span style=&#34;color:#b452cd&#34;&gt;0&lt;/span&gt;,&lt;span style=&#34;color:#b452cd&#34;&gt;1&lt;/span&gt;)) = &lt;span style=&#34;color:#b452cd&#34;&gt;0&lt;/span&gt;
        _FactorY(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;Factor Y&amp;#34;&lt;/span&gt;,Range(&lt;span style=&#34;color:#b452cd&#34;&gt;0&lt;/span&gt;,&lt;span style=&#34;color:#b452cd&#34;&gt;1&lt;/span&gt;)) = &lt;span style=&#34;color:#b452cd&#34;&gt;0&lt;/span&gt;
    }


    CGINCLUDE
    &lt;span style=&#34;color:#1e889b&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#1e889b&#34;&gt;&amp;#34;UnityCG.cginc&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#1e889b&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#1e889b&#34;&gt;&lt;/span&gt;

    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;struct&lt;/span&gt; &lt;span style=&#34;color:#008b45;font-weight:bold&#34;&gt;appdata&lt;/span&gt;
    {
        float4 vertex : POSITION;
        float2 uv : TEXCOORD0;
    };
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;struct&lt;/span&gt; &lt;span style=&#34;color:#008b45;font-weight:bold&#34;&gt;v2f&lt;/span&gt;
    {
        float4 pos : SV_POSITION;
        float2 uv : TEXCOORD0;
    };


    sampler2D _FrontPage;
    float4 _FrontPage_ST;
    sampler2D _BackPage;
    float4 _BackPage_ST;
    half _Angle;
    half _PinLine;
    half _Amount;
    half _FactorX;
    half _FactorY;


    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;inline&lt;/span&gt; v2f &lt;span style=&#34;color:#008b45&#34;&gt;vert_factory&lt;/span&gt; (appdata v,&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;bool&lt;/span&gt; isFront)
    {
        v2f o;
        &lt;span style=&#34;color:#228b22&#34;&gt;// 旋转前将所有顶点移动到装订线处
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;        v.vertex.x += _PinLine;


        &lt;span style=&#34;color:#228b22&#34;&gt;// 在这里执行顶点变形动画
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;float&lt;/span&gt; factor = saturate(&lt;span style=&#34;color:#b452cd&#34;&gt;1&lt;/span&gt; - abs(&lt;span style=&#34;color:#b452cd&#34;&gt;90&lt;/span&gt; - _Angle) / &lt;span style=&#34;color:#b452cd&#34;&gt;90&lt;/span&gt;);
        v.vertex.y -= _Amount * sin(v.vertex.x * &lt;span style=&#34;color:#b452cd&#34;&gt;0.4f&lt;/span&gt; - _FactorY * v.vertex.x) * factor;
        v.vertex.x -= v.vertex.x * factor * _FactorX;


        &lt;span style=&#34;color:#228b22&#34;&gt;// 绕z轴旋转
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;float&lt;/span&gt; angle_rad = radians(-_Angle);
        &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;float&lt;/span&gt; s;&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;float&lt;/span&gt; c;sincos(angle_rad,s,c);
        float2 rotate_ret = v.vertex.xy;
        v.vertex.x = rotate_ret.x * c + rotate_ret.y * s;
        v.vertex.y = rotate_ret.y * c - rotate_ret.x * s;


        &lt;span style=&#34;color:#228b22&#34;&gt;// 旋转后再移动回原位置
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;        v.vertex.x -= _PinLine;
        
        o.pos = UnityObjectToClipPos(v.vertex);
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt;(isFront)
        {
            o.uv = TRANSFORM_TEX(v.uv, _FrontPage);
        }
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;else&lt;/span&gt;
        {
            o.uv = TRANSFORM_TEX(v.uv, _BackPage);
        }
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; o;
    }
    ENDCG


    SubShader
    {
        Pass
        {
            Name &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;FRONT&amp;#34;&lt;/span&gt;
            Offset -&lt;span style=&#34;color:#b452cd&#34;&gt;1&lt;/span&gt;,-&lt;span style=&#34;color:#b452cd&#34;&gt;1&lt;/span&gt;
            Tags{ &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;LightMode&amp;#34;&lt;/span&gt; = &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;LightweightForward&amp;#34;&lt;/span&gt; }
            Cull Back
            CGPROGRAM
            &lt;span style=&#34;color:#1e889b&#34;&gt;#pragma vertex vert_front
&lt;/span&gt;&lt;span style=&#34;color:#1e889b&#34;&gt;&lt;/span&gt;            &lt;span style=&#34;color:#1e889b&#34;&gt;#pragma fragment frag_front
&lt;/span&gt;&lt;span style=&#34;color:#1e889b&#34;&gt;&lt;/span&gt;            v2f vert_front(appdata v)
            {
                &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#008b45&#34;&gt;vert_factory&lt;/span&gt;(v,&lt;span style=&#34;color:#658b00&#34;&gt;true&lt;/span&gt;);
            }
            fixed4 &lt;span style=&#34;color:#008b45&#34;&gt;frag_front&lt;/span&gt;(v2f i) : SV_Target
            {
                &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; tex2D(_FrontPage,i.uv);
            }
            ENDCG
        }
        Pass
        {
            Name &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;BACK&amp;#34;&lt;/span&gt;
            Tags{ &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;LightMode&amp;#34;&lt;/span&gt; = &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;SRPDefaultUnlit&amp;#34;&lt;/span&gt; }
            Cull Front
            Offset -&lt;span style=&#34;color:#b452cd&#34;&gt;1&lt;/span&gt;,-&lt;span style=&#34;color:#b452cd&#34;&gt;1&lt;/span&gt;
            CGPROGRAM
            &lt;span style=&#34;color:#1e889b&#34;&gt;#pragma vertex vert_back
&lt;/span&gt;&lt;span style=&#34;color:#1e889b&#34;&gt;&lt;/span&gt;            &lt;span style=&#34;color:#1e889b&#34;&gt;#pragma fragment frag_back
&lt;/span&gt;&lt;span style=&#34;color:#1e889b&#34;&gt;&lt;/span&gt;            v2f vert_back(appdata v)
            {
                &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#008b45&#34;&gt;vert_factory&lt;/span&gt;(v,&lt;span style=&#34;color:#658b00&#34;&gt;false&lt;/span&gt;);
            }
            fixed4 &lt;span style=&#34;color:#008b45&#34;&gt;frag_back&lt;/span&gt;(v2f i) : SV_Target
            {
                &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; tex2D(_BackPage,i.uv);
            }
            ENDCG
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;正弦函数曲面用来模拟书页从中间开始翻很合适，但是如果想要模拟从边角开始翻页，就需要换一个变形方程，比较合适的是圆锥曲面方程，使用它计算页面在圆锥曲面上的投影位置，原理示意图如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/%E7%AE%80%E6%98%93%E7%BF%BB%E9%A1%B5%E6%95%88%E6%9E%9C%E5%AE%9E%E7%8E%B0.assets/Image-1604592482220.png&#34; alt=&#34;Image&#34;&gt;&lt;/p&gt;
&lt;p&gt;数学原理在http://www2.parc.com/istl/groups/uir/publications/items/UIR-2004-10-Hong-DeformingPages.pdf中。&lt;/p&gt;
&lt;p&gt;现在在顶点着色器中已知任意网格点的坐标P，参数A（我称它为圆锥顶点ConeTop），参数θ（我称它为圆锥旋转角ConeRotateAngle），那么，点O经过圆锥曲面变换后，它落在圆锥面上的坐标T表示如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/%E7%AE%80%E6%98%93%E7%BF%BB%E9%A1%B5%E6%95%88%E6%9E%9C%E5%AE%9E%E7%8E%B0.assets/Image-1604592526377.png&#34; alt=&#34;Image&#34;&gt;&lt;/p&gt;
&lt;p&gt;其中：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/%E7%AE%80%E6%98%93%E7%BF%BB%E9%A1%B5%E6%95%88%E6%9E%9C%E5%AE%9E%E7%8E%B0.assets/Image-1604592536274.png&#34; alt=&#34;Image&#34;&gt;&lt;/p&gt;
&lt;p&gt;转化为着色器代码如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-C++&#34; data-lang=&#34;C++&#34;&gt;&lt;span style=&#34;color:#228b22&#34;&gt;// 在这里执行顶点变形动画
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;float&lt;/span&gt; theta_rad = radians(_ConeRotateAngle);
&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;float&lt;/span&gt; R = sqrt(v.vertex.x * v.vertex.x + pow(v.vertex.z - _ConeTop,&lt;span style=&#34;color:#b452cd&#34;&gt;2&lt;/span&gt;));
&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;float&lt;/span&gt; r = R * sin(theta_rad);
&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;float&lt;/span&gt; alpha = asin(v.vertex.x / R);
&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;float&lt;/span&gt; beta = alpha / sin(theta_rad);
v.vertex.x = r * sin(beta);
v.vertex.z = R + _ConeTop  - r * (&lt;span style=&#34;color:#b452cd&#34;&gt;1&lt;/span&gt; - cos(beta)) * sin(theta_rad);
v.vertex.y = - r * (&lt;span style=&#34;color:#b452cd&#34;&gt;1&lt;/span&gt; - cos(beta)) * cos(theta_rad);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;注意这里z和y与公式中不同，因为Unity的y轴向上，所以交换yz。&lt;/p&gt;
&lt;p&gt;圆锥曲面翻页效果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/%E7%AE%80%E6%98%93%E7%BF%BB%E9%A1%B5%E6%95%88%E6%9E%9C%E5%AE%9E%E7%8E%B0.assets/Image-1604592572956.png&#34; alt=&#34;Image&#34;&gt;&lt;/p&gt;
&lt;p&gt;为了方便控制，在使用圆锥曲线翻页时，需要建立起Angle和A、θ的函数关系，我这里直接用Angle的值在0-180中smoothstep，然后lerp + clamp计算出A和θ。&lt;/p&gt;
&lt;h2 id=&#34;ui遮罩动画&#34;&gt;UI遮罩动画&lt;/h2&gt;
&lt;p&gt;UI遮罩动画分两种，一种是直接在UI上卡动画帧，然后每帧对活动页的Image长方形做Shear剪切变换，这个比较简单，然后注意的是活动页采样的纹理需要额外绘制一张翻页变形的书页纹理(然后我们项目最后选用的也是这种做法)。&lt;/p&gt;
&lt;p&gt;第二种则是用Mask遮罩挡住当前翻页部分，伪装成3D翻页，unitybookpagecurl就是这种做法。&lt;/p&gt;
&lt;p&gt;其原理是：https://www.cnblogs.com/JinT-Hwang/p/9274984.html&lt;/p&gt;
&lt;p&gt;他的博客看他的原理就行，代码建议直接看https://github.com/Dandarawy/Unity3DBookPageCurl&lt;/p&gt;
- http://localhost:1313/post/%E5%AE%9E%E6%97%B6%E6%B8%B2%E6%9F%93%E6%95%88%E6%9E%9C/%E7%AE%80%E6%98%93%E7%BF%BB%E9%A1%B5%E6%95%88%E6%9E%9C%E5%AE%9E%E7%8E%B0/ - copyright.</description>
        </item>
    
    
  </channel>
</rss> 