<html>
<head>
  <title>翻页效果简单实现</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="YXBJ Windows/602263 (zh-CN, DDL); Windows/10.0.0 (Win64); EDAMVersion=V2;"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="617"/>

<div>
  <style>
    body, td {
      margin-right: 40%;
      margin-left:10%;
      margin-top: 50px;
    }
  </style>
<span><div><div><span style="font-size: 24pt;">简易翻页效果实现</span></div><div><font style="font-size: 24pt;"><br/></font></div><div><span style="font-size: 8pt;">    </span></div><div><span style="font-size: 8pt;">2020/07/03</span></div><div><span style="font-size: 8pt;">qiutang</span></div><div><br/></div><div>        翻页效果主要分为顶点着色器动画和UI遮罩动画。我简单的在Unity上分别实现这两个，然后移植到UE上面去。</div><h3><span style="font-size: 14pt;">顶点着色器实现</span></h3><div>        实际上就是网格顶点变形动画，片元着色器就是简单的采样纹理着色，注意正面与背面的区别，重点在于顶点着色器，它的工作内容可以分为两大部分：</div><div><br/></div><div><span style="font-weight: bold;">            #1 顶点翻页变形，选择合适的圆锥曲线或者正弦曲线函数做顶点变化。</span></div><div>      <span style="font-weight: bold;">      #2 将顶点绕轴旋转合适的角度。</span></div><div><br/></div><div>        我首先实现 #2，然后再实现 #1。</div><div>        首先是<span style="font-weight: bold;">将顶点绕轴旋转合适的角度</span>，输入是当前页面的旋转角度，然后将所有的顶点绕着装订轴旋转该角度。</div><div>        输入模型是一个平面模型，10 * 10的平面网格，默认中心点在原点，因此需要将所有顶点都平移一段距离，使得旋转中心轴线在网格的左边或者右边。</div><div>      </div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>// 旋转前将所有顶点移动到装订线处</div><div>v.vertex.x -= _PinLine;</div><div>// 在这里旋转所有顶点</div><div>// 旋转后再移动回原位置</div><div>v.vertex.x += _PinLine;</div></div><div><br/></div><div>        然后旋转部分是绕z轴旋转，旋转矩阵为：</div><div>        <img src="简易翻页效果实现_files/Image.png" type="image/png" data-filename="Image.png" width="367"/></div><div>        转换为代码是：</div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>// 绕z轴旋转</div><div>float angle_rad = radians(-_Angle);</div><div>float s;float c;sincos(angle_rad,s,c);</div><div>float2 rotate_ret = v.vertex.xy;</div><div>v.vertex.x = rotate_ret.x * c + rotate_ret.y * s;</div><div>v.vertex.y = rotate_ret.y * c - rotate_ret.x * s;</div></div><div>        </div><div>        我这里把矩阵展开了，实际上是一样的效果。</div><div>        现在实现平面网格沿着z轴旋转的效果了。</div><div>        接下来加上顶点的变形。</div><div>        根据你选择数学函数的不同，顶点变形的效果也会呈现不同的形状，简单的有正弦曲面函数，复杂的有圆锥曲面函数，也可以用多个频率的正弦曲面函数叠加得到一个好看的形状，我这里试了正弦函数和圆锥曲面函数：</div><div>        首先是正弦函数：</div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>// 在这里执行顶点变形动画</div><div>float factor = saturate(1 - abs(90 - _Angle) / 90);</div><div>v.vertex.y -= _Factor * sin(v.vertex.x * 0.4f - _FactorY * v.vertex.x) * factor;</div><div>v.vertex.x -= v.vertex.x * factor * _FactorX;</div></div><div>        </div><div>        这里直接根据 y = sin(nx)来计算函数曲线。得到的翻页曲面也是正弦形状的。</div><div>        我还添加了系数控制的FactorX和FactorY以及总的y变形系数，便于自定义变形效果。</div><div>        得到的翻页效果如下：</div><div style="text-align: left;">        <img></img><img src="简易翻页效果实现_files/Image [1].png" type="image/png" data-filename="Image.png" width="317"/></div><div>        多页面叠加时可能会有Z-Fighting，这里在前页面Pass渲染时添加上一个Offset来避免。</div><div>        注：关于这个Offset，我查到的资料有：</div><div>        Unity论坛：</div><div>        <a href="https://forum.unity3d.com/threads/offset-parameters.23281/" style="font-size: 0.813rem; color: rgb(0, 102, 204); font-family: Verdana, Arial, Helvetica, sans-serif; text-decoration: underline;">https://forum.unity3d.com/threads/offset-parameters.23281/</a><span style="font-size: 0.813rem; color: rgb(17, 17, 17); font-family: Verdana, Arial, Helvetica, sans-serif;"> </span><span style="font-size: 0.813rem; color: rgb(17, 17, 17); font-family: Verdana, Arial, Helvetica, sans-serif;"> </span></div><div>        或者KH组的解释：</div><div>        <a href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glPolygonOffset.xhtml" style="font-size: 0.813rem; color: rgb(0, 102, 204); font-family: Verdana, Arial, Helvetica, sans-serif;">https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glPolygonOffset.xhtml</a></div><div style="text-align: left;"><div>        也就是绘制时，每一个片元的深度值都会增加一个偏移量offset，它的计算方式：</div><div style="font-size: 0.813rem; margin-top: 1em; margin-bottom: 1em;"><span style="font-size: 0.813rem; color: rgb(17, 17, 17); font-family: Verdana, Arial, Helvetica, sans-serif;-en-paragraph:true;">            offset = (m * factor) + (r * units)</span></div><div style="text-align: left; margin-top: 1em; margin-bottom: 1em;"><span style="font-size: 0.813rem; color: rgb(17, 17, 17); font-family: Verdana, Arial, Helvetica, sans-serif;-en-paragraph:true;">   </span><span style="color: rgb(17, 17, 17); font-family: 微软雅黑;-en-paragraph:true;">     其中，</span><span style="color: rgb(17, 17, 17); font-family: 微软雅黑;-en-paragraph:true;">m是多边形各边深度的斜率中的最大值，它在光栅化阶段计算得到。在光栅化阶段，若一个多边形越是与近裁剪面平行，每个边的深度变化越接近0，m就越接近0。r是NDC空间下的最小深度单位，它是图形Api设置的。</span></div><div style="text-align: left; margin-top: 1em; margin-bottom: 1em;"><span style="color: rgb(17, 17, 17); font-family: 微软雅黑;-en-paragraph:true;">        m的详细计算公式如下：</span><a href="https://www.inf.ufes.br/~thomas/graphics/OpenGL/docs/glspec1.1/node58.html" style="font-size: 0.813rem; color: rgb(0, 102, 204); font-family: Verdana, Arial, Helvetica, sans-serif; text-decoration: underline;-en-paragraph:true;">https://www.inf.ufes.br/~thomas/graphics/OpenGL/docs/glspec1.1/node58.html</a></div><div style="text-align: left; margin-top: 1em; margin-bottom: 1em;"><span style="color: rgb(17, 17, 17); font-family: 微软雅黑;-en-paragraph:true;">        核心步骤为：</span></div><div><img></img><img src="简易翻页效果实现_files/Image [2].png" type="image/png" data-filename="Image.png" width="650"/></div><div><span style="font-size: unset; color: rgb(17, 17, 17);">        一个大于0 的 offset 会把模型推更远一点的位置，一个小于0的offset 会把模型拉近。</span></div><div>        Unity Shader的Offset有两个参数，第一个是因子<span style="font-size: 0.813rem; color: rgb(17, 17, 17); font-family: Verdana, Arial, Helvetica, sans-serif;">factor</span>，第二个是单位<span style="font-size: 0.813rem; color: rgb(17, 17, 17); font-family: Verdana, Arial, Helvetica, sans-serif;">units</span>。</div></div><div style="text-align: left;">        渲染页面时，为避免与其他重叠页面产生z-fight，于是使用Offset，我这里想让Offset 按照多边形的深度斜率变化递增，并且最少offset一个单位的深度，所以设：</div><div style="text-align: left;">        Offset -1,-1</div><div>        当前完整的Shader代码如下：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>Shader &quot;GraphicsLibrary/FlipPaper/SineFlip&quot;</div><div>{</div><div>    Properties</div><div>    {</div><div>        _FrontPage (&quot;Page Front&quot;, 2D) = &quot;white&quot; {}</div><div>        _BackPage  (&quot;Page Back&quot; , 2D) = &quot;white&quot; {}</div><div>        _Angle (&quot;Curl Angle&quot;, Range(0,180)) = 0</div><div>        _PinLine (&quot;Pin Line&quot;, float) = 0</div><div>        _Amount(&quot;Amount&quot;,Range(0,2)) = 0</div><div>        _FactorX(&quot;Factor X&quot;,Range(0,1)) = 0</div><div>        _FactorY(&quot;Factor Y&quot;,Range(0,1)) = 0</div><div>    }</div><div><br/></div><div><br/></div><div>    CGINCLUDE</div><div>    #include &quot;UnityCG.cginc&quot;</div><div><br/></div><div><br/></div><div>    struct appdata</div><div>    {</div><div>        float4 vertex : POSITION;</div><div>        float2 uv : TEXCOORD0;</div><div>    };</div><div>    struct v2f</div><div>    {</div><div>        float4 pos : SV_POSITION;</div><div>        float2 uv : TEXCOORD0;</div><div>    };</div><div><br/></div><div><br/></div><div>    sampler2D _FrontPage;</div><div>    float4 _FrontPage_ST;</div><div>    sampler2D _BackPage;</div><div>    float4 _BackPage_ST;</div><div>    half _Angle;</div><div>    half _PinLine;</div><div>    half _Amount;</div><div>    half _FactorX;</div><div>    half _FactorY;</div><div><br/></div><div><br/></div><div>    inline v2f vert_factory (appdata v,bool isFront)</div><div>    {</div><div>        v2f o;</div><div>        // 旋转前将所有顶点移动到装订线处</div><div>        v.vertex.x += _PinLine;</div><div><br/></div><div><br/></div><div>        // 在这里执行顶点变形动画</div><div>        float factor = saturate(1 - abs(90 - _Angle) / 90);</div><div>        v.vertex.y -= _Amount * sin(v.vertex.x * 0.4f - _FactorY * v.vertex.x) * factor;</div><div>        v.vertex.x -= v.vertex.x * factor * _FactorX;</div><div><br/></div><div><br/></div><div>        // 绕z轴旋转</div><div>        float angle_rad = radians(-_Angle);</div><div>        float s;float c;sincos(angle_rad,s,c);</div><div>        float2 rotate_ret = v.vertex.xy;</div><div>        v.vertex.x = rotate_ret.x * c + rotate_ret.y * s;</div><div>        v.vertex.y = rotate_ret.y * c - rotate_ret.x * s;</div><div><br/></div><div><br/></div><div>        // 旋转后再移动回原位置</div><div>        v.vertex.x -= _PinLine;</div><div>        </div><div>        o.pos = UnityObjectToClipPos(v.vertex);</div><div>        if(isFront)</div><div>        {</div><div>            o.uv = TRANSFORM_TEX(v.uv, _FrontPage);</div><div>        }</div><div>        else</div><div>        {</div><div>            o.uv = TRANSFORM_TEX(v.uv, _BackPage);</div><div>        }</div><div>        return o;</div><div>    }</div><div>    ENDCG</div><div><br/></div><div><br/></div><div>    SubShader</div><div>    {</div><div>        Pass</div><div>        {</div><div>            Name &quot;FRONT&quot;</div><div>            Offset -1,-1</div><div>            Tags{ &quot;LightMode&quot; = &quot;LightweightForward&quot; }</div><div>            Cull Back</div><div>            CGPROGRAM</div><div>            #pragma vertex vert_front</div><div>            #pragma fragment frag_front</div><div>            v2f vert_front(appdata v)</div><div>            {</div><div>                return vert_factory(v,true);</div><div>            }</div><div>            fixed4 frag_front(v2f i) : SV_Target</div><div>            {</div><div>                return tex2D(_FrontPage,i.uv);</div><div>            }</div><div>            ENDCG</div><div>        }</div><div>        Pass</div><div>        {</div><div>            Name &quot;BACK&quot;</div><div>            Tags{ &quot;LightMode&quot; = &quot;SRPDefaultUnlit&quot; }</div><div>            Cull Front</div><div>            Offset -1,-1</div><div>            CGPROGRAM</div><div>            #pragma vertex vert_back</div><div>            #pragma fragment frag_back</div><div>            v2f vert_back(appdata v)</div><div>            {</div><div>                return vert_factory(v,false);</div><div>            }</div><div>            fixed4 frag_back(v2f i) : SV_Target</div><div>            {</div><div>                return tex2D(_BackPage,i.uv);</div><div>            }</div><div>            ENDCG</div><div>        }</div><div>    }</div><div>}</div></div><div style="margin-left: 33px; margin-bottom: 0px; border-right-width: 30px; min-height: 2720px; min-width: 684.525px; padding-right: 0px; padding-bottom: 0px;"><div style="position: relative; top: 0px;"><div style="position: relative; outline: none;"><div style="left: 4px; top: 0px; height: 24px;"><span style="top: 0px; height: 24px;"> </span></div><div style="position: relative;"><span style="position: relative; font-size: unset; color: unset; font-family: unset;"> 正弦函数曲面用来模拟书页从中间开始翻很合适，但是如果想要模拟从边角开始翻页，就需要换一个变形方程，比较合适的是圆锥曲面方程，使用它计算页面在圆锥曲面上的投影位置，原理示意图如下：</span></div><div style="position: relative;"><img src="简易翻页效果实现_files/Image [3].png" type="image/png" data-filename="Image.png" width="319"/></div><div style="position: relative;"><span style="position: relative; font-size: unset; color: unset; font-family: unset;"> 数学原理在</span><a href="http://www2.parc.com/istl/groups/uir/publications/items/UIR-2004-10-Hong-DeformingPages.pdf" style="position: relative; font-size: unset; font-family: unset;">http://www2.parc.com/istl/groups/uir/publications/items/UIR-2004-10-Hong-DeformingPages.pdf</a><span style="position: relative; font-size: unset; color: unset; font-family: unset;">中，我不喜欢推导圆锥曲面公式，所以结论直接拿来用了。</span></div><div style="position: relative;"><span style="position: relative; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; font-size: 10pt; color: rgb(23, 43, 77); font-variant-caps: normal; font-variant-ligatures: normal;">现在在顶点着色器中已知任意网格点的坐标P，参数A（我称它为圆锥顶点ConeTop），参数θ（我称它为圆锥旋转角ConeRotateAngle），那么，点O经过圆锥曲面变换后，它落在圆锥面上的坐标T表示如下：</span></div><div style="position: relative;"><img src="简易翻页效果实现_files/Image [4].png" type="image/png" data-filename="Image.png" width="271"/><span style="position: relative; color: rgb(23, 43, 77);"> </span></div><div style="position: relative;"><span style="position: relative;">        其中：</span></div><div style="position: relative;"><img src="简易翻页效果实现_files/Image [5].png" type="image/png" data-filename="Image.png" width="227"/></div><div style="position: relative;"><span style="position: relative; font-size: 16px; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(23, 43, 77); font-family: Helvetica, &quot;Hiragino Sans GB&quot;, 微软雅黑, &quot;Microsoft YaHei UI&quot;, SimSun, SimHei, arial, sans-serif; font-variant-caps: normal; font-variant-ligatures: normal;">         </span></div><div style="position: relative;"><span style="position: relative; font-size: 16px; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(23, 43, 77); font-family: Helvetica, &quot;Hiragino Sans GB&quot;, 微软雅黑, &quot;Microsoft YaHei UI&quot;, SimSun, SimHei, arial, sans-serif; font-variant-caps: normal; font-variant-ligatures: normal;">        转化为着色器代码如下：</span></div><div style="position: relative;"><br/></div><div style="position: relative;"><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>// 在这里执行顶点变形动画</div><div>float theta_rad = radians(_ConeRotateAngle);</div><div>float R = sqrt(v.vertex.x * v.vertex.x + pow(v.vertex.z - _ConeTop,2));</div><div>float r = R * sin(theta_rad);</div><div>float alpha = asin(v.vertex.x / R);</div><div>float beta = alpha / sin(theta_rad);</div><div>v.vertex.x = r * sin(beta);</div><div>v.vertex.z = R + _ConeTop  - r * (1 - cos(beta)) * sin(theta_rad);</div><div>v.vertex.y = - r * (1 - cos(beta)) * cos(theta_rad);</div></div><div><br/></div></div><div style="margin: 8px 0px 0px; font-size: 16px; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span style="font-size: 16px; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(23, 43, 77); font-family: Helvetica, &quot;Hiragino Sans GB&quot;, 微软雅黑, &quot;Microsoft YaHei UI&quot;, SimSun, SimHei, arial, sans-serif; font-variant-caps: normal; font-variant-ligatures: normal;">        注意这里z和y与公式中不同，因为Unity的y轴向上，所以交换yz。</span></div><div style="position: relative;"><span style="position: relative; font-size: 16px; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(23, 43, 77); font-family: Helvetica, &quot;Hiragino Sans GB&quot;, 微软雅黑, &quot;Microsoft YaHei UI&quot;, SimSun, SimHei, arial, sans-serif; font-variant-caps: normal; font-variant-ligatures: normal;">        圆锥曲面翻页效果如下：</span></div><div style="position: relative;">        <img src="简易翻页效果实现_files/Image [6].png" type="image/png" data-filename="Image.png" width="364"/></div><div style="margin: 8px 0px 0px; font-size: 16px; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><div style="margin: 8px 0px 0px;"><span style="font-size: 16px; color: rgb(23, 43, 77); font-family: Helvetica, &quot;Hiragino Sans GB&quot;, 微软雅黑, &quot;Microsoft YaHei UI&quot;, SimSun, SimHei, arial, sans-serif; font-variant-caps: normal; font-variant-ligatures: normal;">        为了方便控制，在使用圆锥曲线翻页时，需要建立起Angle和A、θ的函数关系，我这里直接用Angle的值在0-180中smoothstep，然后lerp + clamp计算出A和θ。</span></div><h3 style="margin: 1.25rem 0px 0.625rem; padding: 0px; font-size: 1.25rem; text-align: left;"><span style="font-size: 1.25rem; color: rgb(23, 43, 77); font-family: Helvetica, &quot;Hiragino Sans GB&quot;, 微软雅黑, &quot;Microsoft YaHei UI&quot;, SimSun, SimHei, arial, sans-serif; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold;">UI遮罩动画</span></h3><div style="margin: 8px 0px 0px;"><span style="font-size: 16px; color: rgb(23, 43, 77); font-family: Helvetica, &quot;Hiragino Sans GB&quot;, 微软雅黑, &quot;Microsoft YaHei UI&quot;, SimSun, SimHei, arial, sans-serif; font-variant-caps: normal; font-variant-ligatures: normal;">        UI遮罩动画分两种，一种是直接在UI上卡动画帧，然后每帧对活动页的Image长方形做Shear剪切变换，这个比较简单，然后注意的是活动页采样的纹理需要额外绘制一张翻页变形的书页纹理(然后我们项目最后选用的也是这种做法)。</span></div></div><div style="margin: 8px 0px 0px; font-size: 16px; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span style="font-size: 16px; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(23, 43, 77); font-family: Helvetica, &quot;Hiragino Sans GB&quot;, 微软雅黑, &quot;Microsoft YaHei UI&quot;, SimSun, SimHei, arial, sans-serif; font-variant-caps: normal; font-variant-ligatures: normal;">        第二种则是用Mask遮罩挡住当前翻页部分，伪装成3D翻页，unitybookpagecurl就是这种做法。</span></div><div style="margin: 8px 0px 0px; font-size: 16px; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span style="font-size: 16px; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(23, 43, 77); font-family: Helvetica, &quot;Hiragino Sans GB&quot;, 微软雅黑, &quot;Microsoft YaHei UI&quot;, SimSun, SimHei, arial, sans-serif; font-variant-caps: normal; font-variant-ligatures: normal;">        其原理是：</span><a href="https://www.cnblogs.com/JinT-Hwang/p/9274984.html" style="font-size: 16px; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; cursor: pointer; overflow-wrap: break-word; color: rgb(23, 43, 77); font-family: Helvetica, &quot;Hiragino Sans GB&quot;, 微软雅黑, &quot;Microsoft YaHei UI&quot;, SimSun, SimHei, arial, sans-serif; font-variant-caps: normal; font-variant-ligatures: normal;">https://www.cnblogs.com/JinT-Hwang/p/9274984.html</a></div><div style="position: relative;"><span style="position: relative; font-size: 16px; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(23, 43, 77); font-family: Helvetica, &quot;Hiragino Sans GB&quot;, 微软雅黑, &quot;Microsoft YaHei UI&quot;, SimSun, SimHei, arial, sans-serif; font-variant-caps: normal; font-variant-ligatures: normal;">        他的博客看他的原理就行，代码直接看</span><a href="https://github.com/Dandarawy/Unity3DBookPageCurl" style="position: relative; font-size: 0.813rem; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; font-family: verdana, &quot;ms song&quot;, 宋体, Arial, 微软雅黑, Helvetica, sans-serif; font-variant-caps: normal; font-variant-ligatures: normal;">https://github.com/Dandarawy/Unity3DBookPageCurl</a><span style="position: relative; font-size: 0.813rem; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"> </span></div></div></div></div><div><br/></div></div><div><br/></div></span>
</div></body></html>